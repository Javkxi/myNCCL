.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Subclass 3pm"
.TH Subclass 3pm "2007-03-05" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Glib::Object::Subclass \- register a perl class as a GObject class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 20
\&  use Glib::Object::Subclass
\&     Some::Base::Class::,   # parent class, derived from Glib::Object
\&     signals => {
\&            something_changed => {
\&               class_closure => sub { do_something_fun () },
\&               flags         => [qw(run\-first)],
\&               return_type   => undef,
\&               param_types   => [],
\&            },
\&            some_existing_signal => \e&class_closure_override,
\&     },
\&     properties => [
\&        Glib::ParamSpec\->string (
\&           'some_string',
\&           'Some String Property',
\&           'This property is a string that is used as an example',
\&           'default value',
\&           [qw/readable writable/]
\&        ),
\&     ];
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module allows you to create your own GObject classes, which is useful
to e.g. implement your own Gtk2 widgets.
.PP
It doesn't \*(L"export\*(R" anything into your namespace, but acts more like
a pragmatic module that modifies your class to make it work as a
GObject class.
.PP
You may be wondering why you can't just bless a Glib::Object into a
different package and add some subs.  Well, if you aren't interested 
in object parameters, signals, or having your new class interoperate
transparently with other GObject-based modules (e.g., Gtk2 and friends),
then you can just re\-bless.
.PP
However, a GObject's signals, properties, virtual functions, and GInterface
implementations are specific to its GObjectClass.  If you want to create
a new GObject which was a derivative of GtkDrawingArea, but adds a new
signal, you must create a new GObjectClass to which to add the new signal.
If you don't, then \fIall\fR of the GtkDrawingAreas in your application
will get that new signal!
.PP
Thus, the only way to create a new signal or object property in the
Perl bindings for Glib is to register a new subclass with the GLib type
system via \fIGlib::Type::register_object()\fR.
The Glib::Object::Subclass module is a Perl-developer-friendly interface
to this bit of paradigm mismatch.
.Sh "\s-1USAGE\s0"
.IX Subsection "USAGE"
This module works similar to the \f(CW\*(C`use base\*(C'\fR pragma in that it registers
the current package as a subclass of some other class (which must be a
GObjectClass implemented either in C or some other language).
.PP
The pragma requires at least one argument, the parent class name.  The
remaining arguments are key/value pairs, in any order, all optional:
.IP "\- properties => []" 4
.IX Item "- properties => []"
Add object properties; see \*(L"\s-1PROPERTIES\s0\*(R".
.IP "\- signals => {}" 4
.IX Item "- signals => {}"
Add or override signals; see \*(L"\s-1SIGNALS\s0\*(R" and \*(L"\s-1OVERRIDING\s0 \s-1BASE\s0 \s-1METHODS\s0\*(R".
.IP "\- interfaces => []" 4
.IX Item "- interfaces => []"
Add GInterfaces to your class; see \*(L"\s-1INTERFACES\s0\*(R".
.PP
(Actually, these parameters are all passed straight through to
\&\fIGlib::Type::register_object()\fR, adding _\|_PACKAGE_\|_ (the current package name)
as the name of the new child class.)
.Sh "\s-1OBJECT\s0 \s-1METHODS\s0 \s-1AND\s0 \s-1FUNCTIONS\s0"
.IX Subsection "OBJECT METHODS AND FUNCTIONS"
The following methods are either added to your class on request (not
yet implemented), or by default unless your own class implements them
itself. This means that all these methods and functions will get sensible
default implementations unless explicitly overwritten by you (by defining
your own version).
.PP
Except for \f(CW\*(C`new\*(C'\fR, all of the following are \fIfunctions\fR and no
\&\fImethods\fR. That means that you should \fInot\fR call the superclass
method. Instead, the GObject system will call these functions per class as
required, emulating normal inheritance.
.IP "$class\->new (attr => value, ...)" 4
.IX Item "$class->new (attr => value, ...)"
The default constructor just calls \f(CW\*(C`Glib::Object::new\*(C'\fR, which allows you
to set properties on the newly created object. This is done because many
\&\f(CW\*(C`new\*(C'\fR methods inherited by Gtk2 or other libraries don't have \f(CW\*(C`new\*(C'\fR
methods suitable for subclassing.
.ie n .IP "\s-1INIT_INSTANCE\s0 $self                                 [not a method]" 4
.el .IP "\s-1INIT_INSTANCE\s0 \f(CW$self\fR                                 [not a method]" 4
.IX Item "INIT_INSTANCE $self                                 [not a method]"
\&\f(CW\*(C`INIT_INSTANCE\*(C'\fR is called on each class in the hierarchy as the object is
being created (i.e., from \f(CW\*(C`Glib::Object::new\*(C'\fR or our default \f(CW\*(C`new\*(C'\fR). Use
this function to initialize any member data. The default implementation
will leave the object untouched.
.ie n .IP "\s-1GET_PROPERTY\s0 $self\fR, \f(CW$pspec                          [not a method]" 4
.el .IP "\s-1GET_PROPERTY\s0 \f(CW$self\fR, \f(CW$pspec\fR                          [not a method]" 4
.IX Item "GET_PROPERTY $self, $pspec                          [not a method]"
Get a property value, see \f(CW\*(C`SET_PROPERTY\*(C'\fR.
.Sp
The default implementation looks like this:
.Sp
.Vb 2
\&   my ($self, $pspec) = @_;
\&   return ($self\->{$pspec\->get_name} || $pspec\->get_default_value);
.Ve
.ie n .IP "\s-1SET_PROPERTY\s0 $self\fR, \f(CW$pspec\fR, \f(CW$newval                 [not a method]" 4
.el .IP "\s-1SET_PROPERTY\s0 \f(CW$self\fR, \f(CW$pspec\fR, \f(CW$newval\fR                 [not a method]" 4
.IX Item "SET_PROPERTY $self, $pspec, $newval                 [not a method]"
\&\f(CW\*(C`GET_PROPERTY\*(C'\fR and \f(CW\*(C`SET_PROPERTY\*(C'\fR are called whenever somebody does
\&\f(CW\*(C`$object\->get ($propname)\*(C'\fR or \f(CW\*(C`$object\->set ($propname => $newval)\*(C'\fR
(from other languages, too). This is your hook that allows you to
store/fetch properties in any way you need to (maybe you have to calculate
something or read a file).
.Sp
\&\f(CW\*(C`GET_PROPERTY\*(C'\fR is different from a C get_property method in that the
perl method returns the retrieved value. For symmetry, the \f(CW$newval\fR
and \f(CW$pspec\fR args on \f(CW\*(C`SET_PROPERTY\*(C'\fR are swapped from the C usage. The
default get and set methods store property data in the object as hash
values named for the parameter name.
.Sp
The default \f(CW\*(C`SET_PROPERTY\*(C'\fR looks like this:
.Sp
.Vb 2
\&   my ($self, $pspec, $newval) = @_;
\&   $self\->{$pspec\->get_name} = $newval;
.Ve
.ie n .IP "\s-1FINALIZE_INSTANCE\s0 $self                             [not a method]" 4
.el .IP "\s-1FINALIZE_INSTANCE\s0 \f(CW$self\fR                             [not a method]" 4
.IX Item "FINALIZE_INSTANCE $self                             [not a method]"
\&\f(CW\*(C`FINALIZE_INSTANCE\*(C'\fR is called as the GObject is being finalized, that is,
as it is being really destroyed.  This is independent of the more common
\&\s-1DESTROY\s0 on the perl object; in fact, you must \fI\s-1NOT\s0\fR override \f(CW\*(C`DESTROY\*(C'\fR
(it's not useful to you, in any case, as it is being called multiple
times!).
.Sp
Use this hook to release anything you have to clean up manually.
\&\s-1FINALIZE_INSTANCE\s0 will be called for each perl instance, in reverse order
of construction.
.Sp
The default finalizer does nothing.
.IP "$object\->\s-1DESTROY\s0           [\s-1DO\s0 \s-1NOT\s0 \s-1OVERWRITE\s0]" 4
.IX Item "$object->DESTROY           [DO NOT OVERWRITE]"
Don't \fIever\fR overwrite \f(CW\*(C`DESTROY\*(C'\fR, use \f(CW\*(C`FINALIZE_INSTANCE\*(C'\fR instead.
.Sp
The \s-1DESTROY\s0 method of all perl classes derived from GTypes is
implemented in the Glib module and (ab\-)used for its own internal
purposes. Overwriting it is not useful as it will be called
\&\fImultiple\fR times, and often long before the object actually gets
destroyed.  Overwriting might be very harmful to your program, so \fInever\fR
do that.  Especially watch out for other classes in your \s-1ISA\s0 tree.
.SH "PROPERTIES"
.IX Header "PROPERTIES"
To create gobject properties, supply a list of Glib::ParamSpec objects as the
value for the key 'properties'.  There are lots of different paramspec
constructors, documented in the C \s-1API\s0 reference's Parameters and Values page,
as well as Glib::ParamSpec.
.PP
As of Glib 1.060, you can also specify explicit getters and setters for your
properties at creation time.  The default values in your properties are also
honored if you don't set anything else.  See Glib::Type::register_object in
Glib::Type for an example.
.SH "SIGNALS"
.IX Header "SIGNALS"
Creating new signals for your new object is easy.  Just provide a hash
of signal names and signal descriptions under the key 'signals'.  Each
signal description is also a hash, with a few expected keys.  All the 
keys are allowed to default.
.IP "flags => GSignalFlags" 4
.IX Item "flags => GSignalFlags"
If not present, assumed to be 'run\-first'.
.IP "param_types => reference to a list of package names" 4
.IX Item "param_types => reference to a list of package names"
If not present, assumed to be empty (no parameters).
.IP "class_closure => reference to a subroutine to call as the class closure." 4
.IX Item "class_closure => reference to a subroutine to call as the class closure."
may also be a string interpreted as the name of a subroutine to call, but you
should be very very very careful about that.
.Sp
If not present, the library will attempt to call the method named
\&\*(L"do_signal_name\*(R" for the signal \*(L"signal_name\*(R" (uses underscores).
.Sp
You'll want to be careful not to let this handler method be a publically
callable method, or one that has the name name as something that emits the
signal.  Due to the funky ways in which Glib is different from Perl, the
class closures \fIshould not\fR inherit through normal perl inheritance.
.IP "return_type => package name for return value." 4
.IX Item "return_type => package name for return value."
If undefined or not present, the signal expects no return value.  if defined,
the signal is expected to return a value; flags must be set such that the
signal does not run only first (at least use 'run\-last').
.IP "accumulator => signal return value accumulator" 4
.IX Item "accumulator => signal return value accumulator"
quoting the Glib manual: \*(L"The signal accumulator is a special callback function
that can be used to collect return values of the various callbacks that are
called during a signal emission.\*(R"
.Sp
If not specified, the default accumulator is used, and you just get the 
return value of the last handler to run.
.Sp
Accumulators are not really documented very much in the C reference, and
the perl interface here is slightly different, so here's an inordinate amount
of detail for this arcane feature:
.Sp
The accumulator function is called for every handler.  It is given three
arguments: the signal invocation hint as an anonymous hash (containing the
signal name, notably); the current accumulated return value; and the value
returned by the most recent handler.  The accumulator must return two values:
a boolean value determining whether signal emission should continue (false
stops the emission), and the new value for the accumulated return value.
(This is different from the C version, which writes through the return_accu.)
.SH "OVERRIDING BASE METHODS"
.IX Header "OVERRIDING BASE METHODS"
GLib pulls some fancy tricks with function pointers to implement methods
in C.  This is not very language\-binding\-friendly, as you might guess.
.PP
However, as described above, every signal allows a \*(L"class closure\*(R"; you
may override thie class closure with your own function, and you can chain
from the overridden method to the original.  This serves to implement
virtual overrides for language bindings.
.PP
So, to override a method, you supply a subroutine reference instead of a
signal description hash as the value for the name of the existing signal
in the \*(L"signals\*(R" hash described in \*(L"\s-1SIGNALS\s0\*(R".
.PP
.Vb 12
\&  # override some important widget methods:
\&  use Glib::Object::Subclass
\&        Gtk2::Widget::,
\&        signals => {
\&                expose_event => \e&expose_event,
\&                configure_event => \e&configure_event,
\&                button_press_event => \e&button_press_event,
\&                button_release_event => \e&button_release_event,
\&                motion_notify_event => \e&motion_notify_event,
\&                # note the choice of names here... see the discussion.
\&                size_request => \e&do_size_request,
\&        }
.Ve
.PP
It's important to note that the handlers you supply for these are
class\-specific, and that normal perl method inheritance rules are not
followed to invoke them from within the library.  However, perl code can
still find them!  Therefore it's rather important that you choose your
handlers' names carefully, avoiding any public interfaces that you might
call from perl.  Case in point, since size_request is a widget method, i
chose do_size_request as the override handler.
.SH "INTERFACES"
.IX Header "INTERFACES"
GObject supports only single inheritance; in place of multiple inheritance,
GObject uses GInterfaces.  In the Perl bindings we have mostly masqueraded
this with multiple inheritance (that is, simply adding the GInterface class
to the \f(CW@ISA\fR of the implementing class), but in deriving new objects the
facade breaks and the magic leaks out.
.PP
In order to derive an object that implements a GInterface, you have to tell
the GLib type system you want your class to include a GInterface.  To do
this, simply pass a list of package names through the \*(L"interfaces\*(R" key;
this will add these packages to your \f(CW@ISA\fR, and cause perl to invoke methods
that you must provide.
.PP
.Vb 5
\&  package Mup::MultilineEntry;
\&  use Glib::Object::Subclass
\&      'Gtk2::TextView',
\&      interfaces => [ 'Gtk2::CellEditable' ],
\&      ;
.Ve
.PP
.Vb 6
\&  # perl will now invoke these methods, which are part of the
\&  # GtkCellEditable GInterface, when somebody invokes the
\&  # corresponding lower\-case methods on your objects.
\&  sub START_EDITING { warn "start editing\en"; }
\&  sub EDITING_DONE { warn "editing done\en"; }
\&  sub REMOVE_WIDGET { warn "remove widget\en"; }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 1
\&  GObject \- http://developer.gnome.org/doc/API/2.0/gobject/
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Marc Lehmann <schmorp@schmorp.de>, muppet <scott at asofyet dot org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2003\-2004 by muppet and the gtk2\-perl team
.PP
This library is free software; you can redistribute it and/or modify
it under the terms of the Lesser General Public License (\s-1LGPL\s0).  For 
more information, see http://www.fsf.org/licenses/lgpl.txt
