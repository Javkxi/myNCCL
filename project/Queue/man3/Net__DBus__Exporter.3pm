.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::DBus::Exporter 3pm"
.TH Net::DBus::Exporter 3pm "2006-11-05" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Net::DBus::Exporter \- Export object methods and signals to the bus
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  # Define a new package for the object we're going
\&  # to export
\&  package Demo::HelloWorld;
.Ve
.PP
.Vb 2
\&  # Specify the main interface provided by our object
\&  use Net::DBus::Exporter qw(org.example.demo.Greeter);
.Ve
.PP
.Vb 2
\&  # We're going to be a DBus object
\&  use base qw(Net::DBus::Object);
.Ve
.PP
.Vb 2
\&  # Export a 'Greeting' signal taking a stringl string parameter
\&  dbus_signal("Greeting", ["string"]);
.Ve
.PP
.Vb 3
\&  # Export 'Hello' as a method accepting a single string
\&  # parameter, and returning a single string value
\&  dbus_method("Hello", ["string"], ["string"]);
.Ve
.PP
.Vb 4
\&  # Export 'Goodbye' as a method accepting a single string
\&  # parameter, and returning a single string, but put it
\&  # in the 'org.exaple.demo.Farewell' interface
\&  dbus_method("Goodbye", ["string"], ["string"], "org.example.demo.Farewell");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Net::DBus::Exporter\*(C'\fR module is used to export methods
and signals defined in an object to the message bus. Since
Perl is a loosely typed language it is not possible to automatically
determine correct type information for methods to be exported.
Thus when sub-classing Net::DBus::Object, this package will
provide the type information for methods and signals.
.PP
When importing this package, an optional argument can be supplied
to specify the default interface name to associate with methods
and signals, for which an explicit interface is not specified.
Thus in the common case of objects only providing a single interface,
this removes the need to repeat the interface name against each
method exported.
.SH "SCALAR TYPES"
.IX Header "SCALAR TYPES"
When specifying scalar data types for parameters and return values,
the following string constants must be used to denote the data
type. When values corresponding to these types are (un)marshalled
they are represented as the Perl \s-1SCALAR\s0 data type (see perldata).
.ie n .IP """string""" 4
.el .IP "``string''" 4
.IX Item "string"
A \s-1UTF\-8\s0 string of characters
.ie n .IP """int16""" 4
.el .IP "``int16''" 4
.IX Item "int16"
A 16\-bit signed integer
.ie n .IP """uint16""" 4
.el .IP "``uint16''" 4
.IX Item "uint16"
A 16\-bit unsigned integer
.ie n .IP """int32""" 4
.el .IP "``int32''" 4
.IX Item "int32"
A 32\-bit signed integer
.ie n .IP """uint32""" 4
.el .IP "``uint32''" 4
.IX Item "uint32"
A 32\-bit unsigned integer
.ie n .IP """int64""" 4
.el .IP "``int64''" 4
.IX Item "int64"
A 64\-bit signed integer. \s-1NB\s0, this type is not supported by
many builds of Perl on 32\-bit platforms, so if used, your
data is liable to be truncated at 32\-bits.
.ie n .IP """uint64""" 4
.el .IP "``uint64''" 4
.IX Item "uint64"
A 64\-bit unsigned integer. \s-1NB\s0, this type is not supported by
many builds of Perl on 32\-bit platforms, so if used, your
data is liable to be truncated at 32\-bits.
.ie n .IP """byte""" 4
.el .IP "``byte''" 4
.IX Item "byte"
A single 8\-bit byte
.ie n .IP """bool""" 4
.el .IP "``bool''" 4
.IX Item "bool"
A boolean value
.ie n .IP """double""" 4
.el .IP "``double''" 4
.IX Item "double"
An \s-1IEEE\s0 double-precision floating point
.SH "COMPOUND TYPES"
.IX Header "COMPOUND TYPES"
When specifying compound data types for parameters and return
values, an array reference must be used, with the first element
being the name of the compound type. 
.ie n .IP "[""array"", \s-1ARRAY\-TYPE\s0]" 4
.el .IP "[``array'', \s-1ARRAY\-TYPE\s0]" 4
.IX Item "[array, ARRAY-TYPE]"
An array of values, whose type os \f(CW\*(C`ARRAY\-TYPE\*(C'\fR. The \f(CW\*(C`ARRAY\-TYPE\*(C'\fR
can be either a scalar type name, or a nested compound type. When
values corresponding to the array type are (un)marshalled, they 
are represented as the Perl \s-1ARRAY\s0 data type (see perldata). If,
for example, a method was declared to have a single parameter with
the type, [\*(L"array\*(R", \*(L"string\*(R"], then when calling the method one
would provide a array reference of strings:
.Sp
.Vb 1
\&    $object\->hello(["John", "Doe"])
.Ve
.ie n .IP "[""dict"", \s-1KEY\-TYPE\s0, \s-1VALUE\-TYPE\s0]" 4
.el .IP "[``dict'', \s-1KEY\-TYPE\s0, \s-1VALUE\-TYPE\s0]" 4
.IX Item "[dict, KEY-TYPE, VALUE-TYPE]"
A dictionary of values, more commonly known as a hash table. The
\&\f(CW\*(C`KEY\-TYPE\*(C'\fR is the name of the scalar data type used for the dictionary
keys. The \f(CW\*(C`VALUE\-TYPE\*(C'\fR is the name of the scalar, or compound
data type used for the dictionary values. When values corresponding
to the dict type are (un)marshalled, they are represented as the
Perl \s-1HASH\s0 data type (see perldata). If, for example, a method was
declared to have a single parameter with the type [\*(L"dict\*(R", \*(L"string\*(R", \*(L"string\*(R"],
then when calling the method one would provide a hash reference 
of strings,
.Sp
.Vb 1
\&   $object\->hello({forename => "John", surname => "Doe"});
.Ve
.ie n .IP "[""struct"", \s-1VALUE\-TYPE\-1\s0, \s-1VALUE\-TYPE\-2\s0]" 4
.el .IP "[``struct'', \s-1VALUE\-TYPE\-1\s0, \s-1VALUE\-TYPE\-2\s0]" 4
.IX Item "[struct, VALUE-TYPE-1, VALUE-TYPE-2]"
A structure of values, best thought of as a variation on the array
type where the elements can vary. Many languages have an explicit
name associated with each value, but since Perl does not have a
native representation of structures, they are represented by the
\&\s-1LIST\s0 data type. If, for exaple, a method was declared to have a single
parameter with the type [\*(L"struct\*(R", \*(L"string\*(R", \*(L"string\*(R"], corresponding
to the C structure 
.Sp
.Vb 4
\&    struct {
\&      char *forename;
\&      char *surname;
\&    } name;
.Ve
.Sp
then, when calling the method one would provide an array refernce
with the values orded to match the structure
.Sp
.Vb 1
\&   $object\->hello(["John", "Doe"]);
.Ve
.SH "MAGIC TYPES"
.IX Header "MAGIC TYPES"
When specifying introspection data for an exported service, there
are a couple of so called \f(CW\*(C`magic\*(C'\fR types. Parameters declared as
magic types are not visible to clients, but instead their values
are provided automatically by the server side bindings. One use of
magic types is to get an extra parameter passed with the unique 
name of the caller invoking the method.
.ie n .IP """caller""" 4
.el .IP "``caller''" 4
.IX Item "caller"
The value passed in is the unique name of the caller of the method.
Unique names are strings automatically assigned to client connections
by the bus daemon, for example ':1.15'
.ie n .IP """serial""" 4
.el .IP "``serial''" 4
.IX Item "serial"
The value passed in is an integer within the scope of a caller, which 
increments on every method call. 
.SH "ANNOTATIONS"
.IX Header "ANNOTATIONS"
When exporting methods, signals & properties, in addition to the core
data typing information, a number of metadata annotations are possible.
These are specified by passing a hash reference with the desired keys
as the last parameter when defining the export. The following annotations
are currently supported
.IP "no_return" 4
.IX Item "no_return"
Indicate that this method does not return any value, and thus no reply
message should be sent over the wire, likewise informing the clients
not to expect / wait for a reply message
.IP "deprecated" 4
.IX Item "deprecated"
Indicate that use of this method/signal/property is discouraged, and 
it may disappear altogether in a future release. Clients will typically
print out a warning message when a deprecated method/signal/property
is used.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "dbus_method($name, $params\fR, \f(CW$returns, [\e%annotations]);" 4
.el .IP "dbus_method($name, \f(CW$params\fR, \f(CW$returns\fR, [\e%annotations]);" 4
.IX Item "dbus_method($name, $params, $returns, [%annotations]);"
.PD 0
.ie n .IP "dbus_method($name, $params\fR, \f(CW$returns\fR, \f(CW$interface, [\e%annotations]);" 4
.el .IP "dbus_method($name, \f(CW$params\fR, \f(CW$returns\fR, \f(CW$interface\fR, [\e%annotations]);" 4
.IX Item "dbus_method($name, $params, $returns, $interface, [%annotations]);"
.PD
Exports a method called \f(CW$name\fR, having parameters whose types
are defined by \f(CW$params\fR, and returning values whose types are
defined by \f(CW$returns\fR. If the \f(CW$interface\fR parameter is 
provided, then the method is associated with that interface, otherwise
the default interface for the calling package is used. The
value for the \f(CW$params\fR parameter should be an array reference
with each element defining the data type of a parameter to the
method. Likewise, the \f(CW$returns\fR parameter should be an array 
reference with each element defining the data type of a return
value. If it not possible to export a method which accepts a
variable number of parameters, or returns a variable number of
values.
.ie n .IP "dbus_property($name, $type\fR, \f(CW$access, [\e%attributes]);" 4
.el .IP "dbus_property($name, \f(CW$type\fR, \f(CW$access\fR, [\e%attributes]);" 4
.IX Item "dbus_property($name, $type, $access, [%attributes]);"
.PD 0
.ie n .IP "dbus_property($name, $type\fR, \f(CW$access\fR, \f(CW$interface, [\e%attributes]);" 4
.el .IP "dbus_property($name, \f(CW$type\fR, \f(CW$access\fR, \f(CW$interface\fR, [\e%attributes]);" 4
.IX Item "dbus_property($name, $type, $access, $interface, [%attributes]);"
.PD
Exports a property called \f(CW$name\fR, whose data type is \f(CW$type\fR.
If the \f(CW$interface\fR parameter is provided, then the property is 
associated with that interface, otherwise the default interface 
for the calling package is used. 
.ie n .IP "dbus_signal($name, $params);" 4
.el .IP "dbus_signal($name, \f(CW$params\fR);" 4
.IX Item "dbus_signal($name, $params);"
.PD 0
.ie n .IP "dbus_signal($name, $params\fR, \f(CW$interface);" 4
.el .IP "dbus_signal($name, \f(CW$params\fR, \f(CW$interface\fR);" 4
.IX Item "dbus_signal($name, $params, $interface);"
.PD
Exports a signal called \f(CW$name\fR, having parameters whose types
are defined by \f(CW$params\fR, and returning values whose types are
defined by \f(CW$returns\fR. If the \f(CW$interface\fR parameter is 
provided, then the signal is associated with that interface, otherwise
the default interface for the calling package is used. The
value for the \f(CW$params\fR parameter should be an array reference
with each element defining the data type of a parameter to the
signal. Signals do not have return values. It not possible to 
export a signal which has a variable number of parameters.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.IP "No paramters, no return values" 4
.IX Item "No paramters, no return values"
A method which simply prints \*(L"Hello World\*(R" each time its called
.Sp
.Vb 4
\&   sub Hello {
\&       my $self = shift;
\&       print "Hello World\en";
\&   }
.Ve
.Sp
.Vb 1
\&   dbus_method("Hello", [], []);
.Ve
.IP "One string parameter, returning an boolean value" 4
.IX Item "One string parameter, returning an boolean value"
A method which accepts a process name, issues the killall
command on it, and returns a boolean value to indicate whether
it was successful.
.Sp
.Vb 6
\&   sub KillAll {
\&       my $self = shift;
\&       my $processname = shift;
\&       my $ret  = system("killall $processname");
\&       return $ret == 0 ? 1 : 0;
\&   }
.Ve
.Sp
.Vb 1
\&   dbus_method("KillAll", ["string"], ["bool"]);
.Ve
.IP "One list of strings parameter, returning a dictionary" 4
.IX Item "One list of strings parameter, returning a dictionary"
A method which accepts a list of files names, stats them, and
returns a dictionary containing the last modification times.
.Sp
.Vb 3
\&    sub LastModified {
\&       my $self = shift;
\&       my $files = shift;
.Ve
.Sp
.Vb 6
\&       my %mods;
\&       foreach my $file (@{$files}) {
\&          $mods{$file} = (stat $file)[9];
\&       }
\&       return \e%mods;
\&    }
.Ve
.Sp
.Vb 1
\&    dbus_method("LastModified", ["array", "string"], ["dict", "string", "int32"]);
.Ve
.IP "Annotating methods with metdata" 4
.IX Item "Annotating methods with metdata"
A method which is targetted for removal, and also does not
return any value
.Sp
.Vb 3
\&    sub PlayMP3 {
\&        my $self = shift;
\&        my $track = shift;
.Ve
.Sp
.Vb 2
\&        system "mpg123 $track &";
\&    }
.Ve
.Sp
.Vb 1
\&    dbus_method("PlayMP3", ["string"], [], { deprecated => 1, no_return => 1 });
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::DBus::Object, Net::DBus::Binding::Introspector
.SH "AUTHORS"
.IX Header "AUTHORS"
Daniel P. Berrange <dan@berrange.com>
