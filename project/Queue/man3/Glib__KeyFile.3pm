.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Glib::KeyFile 3pm"
.TH Glib::KeyFile 3pm "2007-03-05" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Glib::KeyFile \-  Parser for .ini\-like files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Glib;
.Ve
.PP
.Vb 1
\&  $data .= $_ while (<DATA>);
.Ve
.PP
.Vb 18
\&  $f = Glib::KeyFile\->new;
\&  $f\->load_from_data($data);
\&  if ($f\->has_group('Main') && $f\->has_key('Main', 'someotherkey')) {
\&      $val = $f\->get_integer('Main', 'someotherkey');
\&      print $val . "\en";
\&  }
\&  0;
\&  __DATA__
\&  # a comment
\&  [MainSection]
\&  somekey=somevalue
\&  someotherkey=42
\&  someboolkey=true
\&  listkey=1;1;2;3;5;8;13;21
\&  localekey=Good Morning
\&  localekey[it]=Buon giorno
\&  localekey[es]=Buenas dias
\&  localekey[fr]=Bonjour
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBGlib::KeyFile\fR lets you parse, edit or create files containing groups of
key-value pairs, which we call key files for lack of a better name. Several
freedesktop.org specifications use key files now, e.g the Desktop Entry
Specification and the Icon Theme Specification.
.PP
The syntax of key files is described in detail in the Desktop Entry
Specification, here is a quick summary: Key files consists of groups of
key-value pairs, interspersed with comments.
.SH "METHODS"
.IX Header "METHODS"
.Sh "keyfile = Glib::KeyFile\->\fBnew\fP"
.IX Subsection "keyfile = Glib::KeyFile->new"
.ie n .Sh "boolean = $key_file\fP\->\fBget_boolean\fP ($group_name, \f(CW$key)"
.el .Sh "boolean = \f(CW$key_file\fP\->\fBget_boolean\fP ($group_name, \f(CW$key\fP)"
.IX Subsection "boolean = $key_file->get_boolean ($group_name, $key)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.RE
.RS 4
.PD
.Sp
Retrieves a boolean value from \f(CW$key\fR inside \f(CW$group_name\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "list = $key_file\fP\->\fBget_boolean_list\fP ($group_name, \f(CW$key)"
.el .Sh "list = \f(CW$key_file\fP\->\fBget_boolean_list\fP ($group_name, \f(CW$key\fP)"
.IX Subsection "list = $key_file->get_boolean_list ($group_name, $key)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.RE
.RS 4
.PD
.Sp
Retrieves a list of booleans from \f(CW$key\fR inside \f(CW$group_name\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$key_file\->\fBset_boolean_list\fP ($group_name, $key, ...)"
.el .Sh "$key_file\->\fBset_boolean_list\fP ($group_name, \f(CW$key\fP, ...)"
.IX Subsection "$key_file->set_boolean_list ($group_name, $key, ...)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.IP "* ... (list) list of booleans" 4
.IX Item "... (list) list of booleans"
.RE
.RS 4
.PD
.Sp
Sets a list of booleans in \f(CW$key\fR inside \f(CW$group_name\fR.  If \f(CW$key\fR cannot be found
then it is created.  If \f(CW$group_name\fR cannot be found then it is created.
.RE
.ie n .Sh "$key_file\->\fBset_boolean\fP ($group_name, $key\fP, \f(CW$value)"
.el .Sh "$key_file\->\fBset_boolean\fP ($group_name, \f(CW$key\fP, \f(CW$value\fP)"
.IX Subsection "$key_file->set_boolean ($group_name, $key, $value)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.ie n .IP "* $value (boolean)" 4
.el .IP "* \f(CW$value\fR (boolean)" 4
.IX Item "$value (boolean)"
.RE
.RS 4
.PD
.Sp
Sets a boolean value to \f(CW$key\fR inside \f(CW$group_name\fR.
If \f(CW$key\fR is not found, it is created.
.RE
.ie n .Sh "string = $key_file\fP\->\fBget_comment\fP ($group_name=undef, \f(CW$key=undef)"
.el .Sh "string = \f(CW$key_file\fP\->\fBget_comment\fP ($group_name=undef, \f(CW$key\fP=undef)"
.IX Subsection "string = $key_file->get_comment ($group_name=undef, $key=undef)"
.RS 4
.ie n .IP "* $group_name (string or undef)" 4
.el .IP "* \f(CW$group_name\fR (string or undef)" 4
.IX Item "$group_name (string or undef)"
.PD 0
.ie n .IP "* $key (string or undef)" 4
.el .IP "* \f(CW$key\fR (string or undef)" 4
.IX Item "$key (string or undef)"
.RE
.RS 4
.PD
.Sp
Retreives a comment above \f(CW$key\fR from \f(CW$group_name\fR.  If \f(CW$key\fR is undef then
\&\f(CW$comment\fR will be read from above \f(CW$group_name\fR.  If both \f(CW$key\fR and \f(CW$group_name\fR
are undef, then \f(CW$comment\fR will be read from above the first group in the file.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$key_file\->\fBset_comment\fP ($group_name, $key\fP, \f(CW$comment)"
.el .Sh "$key_file\->\fBset_comment\fP ($group_name, \f(CW$key\fP, \f(CW$comment\fP)"
.IX Subsection "$key_file->set_comment ($group_name, $key, $comment)"
.RS 4
.ie n .IP "* $group_name (string or undef)" 4
.el .IP "* \f(CW$group_name\fR (string or undef)" 4
.IX Item "$group_name (string or undef)"
.PD 0
.ie n .IP "* $key (string or undef)" 4
.el .IP "* \f(CW$key\fR (string or undef)" 4
.IX Item "$key (string or undef)"
.ie n .IP "* $comment (string)" 4
.el .IP "* \f(CW$comment\fR (string)" 4
.IX Item "$comment (string)"
.RE
.RS 4
.PD
.Sp
Places a comment above \f(CW$key\fR from \f(CW$group_name\fR.  If \f(CW$key\fR is undef then \f(CW$comment\fR
will be written above \f(CW$group_name\fR.  If both \f(CW$key\fR and \f(CW$group_name\fR are undef,
then \f(CW$comment\fR will be written above the first group in the file.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "double = $key_file\fP\->\fBget_double\fP ($group_name, \f(CW$key)"
.el .Sh "double = \f(CW$key_file\fP\->\fBget_double\fP ($group_name, \f(CW$key\fP)"
.IX Subsection "double = $key_file->get_double ($group_name, $key)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.RE
.RS 4
.PD
.Sp
Retrieves a double value from \f(CW$key\fR inside \f(CW$group_name\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "list = $key_file\fP\->\fBget_double_list\fP ($group_name, \f(CW$key)"
.el .Sh "list = \f(CW$key_file\fP\->\fBget_double_list\fP ($group_name, \f(CW$key\fP)"
.IX Subsection "list = $key_file->get_double_list ($group_name, $key)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.RE
.RS 4
.PD
.Sp
Retrieves a list of doubles from \f(CW$key\fR inside \f(CW$group_name\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$key_file\->\fBset_double_list\fP ($group_name, $key, ...)"
.el .Sh "$key_file\->\fBset_double_list\fP ($group_name, \f(CW$key\fP, ...)"
.IX Subsection "$key_file->set_double_list ($group_name, $key, ...)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.IP "* ... (list) list of doubles" 4
.IX Item "... (list) list of doubles"
.RE
.RS 4
.PD
.Sp
Sets a list of doubles in \f(CW$key\fR inside \f(CW$group_name\fR.  If \f(CW$key\fR cannot be found
then it is created.  If \f(CW$group_name\fR cannot be found then it is created.
.RE
.ie n .Sh "$key_file\->\fBset_double\fP ($group_name, $key\fP, \f(CW$value)"
.el .Sh "$key_file\->\fBset_double\fP ($group_name, \f(CW$key\fP, \f(CW$value\fP)"
.IX Subsection "$key_file->set_double ($group_name, $key, $value)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.ie n .IP "* $value (double)" 4
.el .IP "* \f(CW$value\fR (double)" 4
.IX Item "$value (double)"
.RE
.RS 4
.PD
.Sp
Sets a double value to \f(CW$key\fR inside \f(CW$group_name\fR.
If \f(CW$key\fR is not found, it is created.
.RE
.ie n .Sh "list = $key_file\fP\->\fBget_groups"
.el .Sh "list = \f(CW$key_file\fP\->\fBget_groups\fP"
.IX Subsection "list = $key_file->get_groups"
.RS 4
Returns the list of groups inside the key_file.
.RE
.ie n .Sh "boolean = $key_file\fP\->\fBhas_group ($group_name)"
.el .Sh "boolean = \f(CW$key_file\fP\->\fBhas_group\fP ($group_name)"
.IX Subsection "boolean = $key_file->has_group ($group_name)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.RE
.RS 4
.Sp
Checks whether \f(CW$group_name\fR is present in \f(CW$key_file\fR.
.RE
.ie n .Sh "boolean = $key_file\fP\->\fBhas_key\fP ($group_name, \f(CW$key)"
.el .Sh "boolean = \f(CW$key_file\fP\->\fBhas_key\fP ($group_name, \f(CW$key\fP)"
.IX Subsection "boolean = $key_file->has_key ($group_name, $key)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.RE
.RS 4
.PD
.Sp
Checks whether \f(CW$group_name\fR has \f(CW$key\fR in it.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "integer = $key_file\fP\->\fBget_integer\fP ($group_name, \f(CW$key)"
.el .Sh "integer = \f(CW$key_file\fP\->\fBget_integer\fP ($group_name, \f(CW$key\fP)"
.IX Subsection "integer = $key_file->get_integer ($group_name, $key)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.RE
.RS 4
.PD
.Sp
Retrieves an integer value from \f(CW$key\fR inside \f(CW$group_name\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "list = $key_file\fP\->\fBget_integer_list\fP ($group_name, \f(CW$key)"
.el .Sh "list = \f(CW$key_file\fP\->\fBget_integer_list\fP ($group_name, \f(CW$key\fP)"
.IX Subsection "list = $key_file->get_integer_list ($group_name, $key)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.RE
.RS 4
.PD
.Sp
Retrieves a list of integers from \f(CW$key\fR inside \f(CW$group_name\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$key_file\->\fBset_integer_list\fP ($group_name, $key, ...)"
.el .Sh "$key_file\->\fBset_integer_list\fP ($group_name, \f(CW$key\fP, ...)"
.IX Subsection "$key_file->set_integer_list ($group_name, $key, ...)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.IP "* ... (list) list of integers" 4
.IX Item "... (list) list of integers"
.RE
.RS 4
.PD
.Sp
Sets a list of doubles in \f(CW$key\fR inside \f(CW$group_name\fR.  If \f(CW$key\fR cannot be found
then it is created.  If \f(CW$group_name\fR cannot be found then it is created.
.RE
.ie n .Sh "$key_file\->\fBset_integer\fP ($group_name, $key\fP, \f(CW$value)"
.el .Sh "$key_file\->\fBset_integer\fP ($group_name, \f(CW$key\fP, \f(CW$value\fP)"
.IX Subsection "$key_file->set_integer ($group_name, $key, $value)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.ie n .IP "* $value (integer)" 4
.el .IP "* \f(CW$value\fR (integer)" 4
.IX Item "$value (integer)"
.RE
.RS 4
.PD
.Sp
Sets an integer value to \f(CW$key\fR inside \f(CW$group_name\fR.
If \f(CW$key\fR is not found, it is created.
.RE
.ie n .Sh "list = $key_file\fP\->\fBget_keys ($group_name)"
.el .Sh "list = \f(CW$key_file\fP\->\fBget_keys\fP ($group_name)"
.IX Subsection "list = $key_file->get_keys ($group_name)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.RE
.RS 4
.Sp
Returns the list of keys inside a group of the key file.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.Sh "$key_file\->\fBset_list_separator\fP ($separator)"
.IX Subsection "$key_file->set_list_separator ($separator)"
.RS 4
.ie n .IP "* $separator (string)" 4
.el .IP "* \f(CW$separator\fR (string)" 4
.IX Item "$separator (string)"
.RE
.RS 4
.Sp
Sets the list separator character.
.RE
.ie n .Sh "boolean = $key_file\fP\->\fBload_from_data\fP ($buf, \f(CW$flags)"
.el .Sh "boolean = \f(CW$key_file\fP\->\fBload_from_data\fP ($buf, \f(CW$flags\fP)"
.IX Subsection "boolean = $key_file->load_from_data ($buf, $flags)"
.RS 4
.ie n .IP "* $buf (scalar)" 4
.el .IP "* \f(CW$buf\fR (scalar)" 4
.IX Item "$buf (scalar)"
.PD 0
.ie n .IP "* $flags (Glib::KeyFileFlags)" 4
.el .IP "* \f(CW$flags\fR (Glib::KeyFileFlags)" 4
.IX Item "$flags (Glib::KeyFileFlags)"
.RE
.RS 4
.PD
.Sp
Parses a string containing a key file structure.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "boolean = $key_file\fP\->\fBload_from_data_dirs\fP ($file, \f(CW$flags)"
.el .Sh "boolean = \f(CW$key_file\fP\->\fBload_from_data_dirs\fP ($file, \f(CW$flags\fP)"
.IX Subsection "boolean = $key_file->load_from_data_dirs ($file, $flags)"
.ie n .Sh "(boolean, scalar) = $key_file\fP\->\fBload_from_data_dirs\fP ($file, \f(CW$flags)"
.el .Sh "(boolean, scalar) = \f(CW$key_file\fP\->\fBload_from_data_dirs\fP ($file, \f(CW$flags\fP)"
.IX Subsection "(boolean, scalar) = $key_file->load_from_data_dirs ($file, $flags)"
.RS 4
.ie n .IP "* $file (string)" 4
.el .IP "* \f(CW$file\fR (string)" 4
.IX Item "$file (string)"
.PD 0
.ie n .IP "* $flags (Glib::KeyFileFlags)" 4
.el .IP "* \f(CW$flags\fR (Glib::KeyFileFlags)" 4
.IX Item "$flags (Glib::KeyFileFlags)"
.RE
.RS 4
.PD
.Sp
Parses a key file, searching for it inside the data directories.
In scalar context, it returns a boolean value (true on success, false otherwise);
in array context, it returns a boolean value and the full path of the file.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "boolean = $key_file\fP\->\fBload_from_file\fP ($file, \f(CW$flags)"
.el .Sh "boolean = \f(CW$key_file\fP\->\fBload_from_file\fP ($file, \f(CW$flags\fP)"
.IX Subsection "boolean = $key_file->load_from_file ($file, $flags)"
.RS 4
.ie n .IP "* $file (string)" 4
.el .IP "* \f(CW$file\fR (string)" 4
.IX Item "$file (string)"
.PD 0
.ie n .IP "* $flags (Glib::KeyFileFlags)" 4
.el .IP "* \f(CW$flags\fR (Glib::KeyFileFlags)" 4
.IX Item "$flags (Glib::KeyFileFlags)"
.RE
.RS 4
.PD
.Sp
Parses a key file.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "string = $key_file\fP\->\fBget_locale_string\fP ($group_name, \f(CW$key\fP, \f(CW$locale=undef)"
.el .Sh "string = \f(CW$key_file\fP\->\fBget_locale_string\fP ($group_name, \f(CW$key\fP, \f(CW$locale\fP=undef)"
.IX Subsection "string = $key_file->get_locale_string ($group_name, $key, $locale=undef)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.ie n .IP "* $locale (string or undef)" 4
.el .IP "* \f(CW$locale\fR (string or undef)" 4
.IX Item "$locale (string or undef)"
.RE
.RS 4
.PD
.Sp
Returns the value associated with \f(CW$key\fR under \f(CW$group_name\fR translated in the
given \f(CW$locale\fR if available.  If \f(CW$locale\fR is undef then the current locale is
assumed.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "list = $key_file\fP\->\fBget_locale_string_list\fP ($group_name, \f(CW$key\fP, \f(CW$locale)"
.el .Sh "list = \f(CW$key_file\fP\->\fBget_locale_string_list\fP ($group_name, \f(CW$key\fP, \f(CW$locale\fP)"
.IX Subsection "list = $key_file->get_locale_string_list ($group_name, $key, $locale)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.ie n .IP "* $locale (string)" 4
.el .IP "* \f(CW$locale\fR (string)" 4
.IX Item "$locale (string)"
.RE
.RS 4
.PD
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$key_file\->\fBset_locale_string_list\fP ($group_name, $key\fP, \f(CW$locale, ...)"
.el .Sh "$key_file\->\fBset_locale_string_list\fP ($group_name, \f(CW$key\fP, \f(CW$locale\fP, ...)"
.IX Subsection "$key_file->set_locale_string_list ($group_name, $key, $locale, ...)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.ie n .IP "* $locale (string)" 4
.el .IP "* \f(CW$locale\fR (string)" 4
.IX Item "$locale (string)"
.IP "* ... (list)" 4
.IX Item "... (list)"
.RE
.RS 4
.PD
.Sp
Associates a list of string values for \f(CW$key\fR and \f(CW$locale\fR under \f(CW$group_name\fR.
If the translation for \f(CW$key\fR cannot be found then it is created.
.RE
.ie n .Sh "$key_file\->\fBset_locale_string\fP ($group_name, $key\fP, \f(CW$locale\fP, \f(CW$string)"
.el .Sh "$key_file\->\fBset_locale_string\fP ($group_name, \f(CW$key\fP, \f(CW$locale\fP, \f(CW$string\fP)"
.IX Subsection "$key_file->set_locale_string ($group_name, $key, $locale, $string)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.ie n .IP "* $locale (string)" 4
.el .IP "* \f(CW$locale\fR (string)" 4
.IX Item "$locale (string)"
.ie n .IP "* $string (string)" 4
.el .IP "* \f(CW$string\fR (string)" 4
.IX Item "$string (string)"
.RE
.RS 4
.RE
.PD
.ie n .Sh "$key_file\->\fBremove_comment\fP ($group_name=undef, $key=undef)"
.el .Sh "$key_file\->\fBremove_comment\fP ($group_name=undef, \f(CW$key\fP=undef)"
.IX Subsection "$key_file->remove_comment ($group_name=undef, $key=undef)"
.RS 4
.ie n .IP "* $group_name (string or undef)" 4
.el .IP "* \f(CW$group_name\fR (string or undef)" 4
.IX Item "$group_name (string or undef)"
.PD 0
.ie n .IP "* $key (string or undef)" 4
.el .IP "* \f(CW$key\fR (string or undef)" 4
.IX Item "$key (string or undef)"
.RE
.RS 4
.PD
.Sp
Removes a comment from a group in a key file.  If \f(CW$key\fR is undef, the comment
will be removed from above \f(CW$group_name\fR.  If both \f(CW$key\fR and \f(CW$group_name\fR are
undef, the comment will be removed from the top of the key file.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.Sh "$key_file\->\fBremove_group\fP ($group_name)"
.IX Subsection "$key_file->remove_group ($group_name)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.RE
.RS 4
.Sp
Removes a group from a key file.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$key_file\->\fBremove_key\fP ($group_name, $key)"
.el .Sh "$key_file\->\fBremove_key\fP ($group_name, \f(CW$key\fP)"
.IX Subsection "$key_file->remove_key ($group_name, $key)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.RE
.RS 4
.PD
.Sp
Removes a key from \f(CW$group_name\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "string = $key_file\fP\->\fBget_start_group"
.el .Sh "string = \f(CW$key_file\fP\->\fBget_start_group\fP"
.IX Subsection "string = $key_file->get_start_group"
.RS 4
Returns the first group inside a key file.
.RE
.ie n .Sh "string = $key_file\fP\->\fBget_string\fP ($group_name, \f(CW$key)"
.el .Sh "string = \f(CW$key_file\fP\->\fBget_string\fP ($group_name, \f(CW$key\fP)"
.IX Subsection "string = $key_file->get_string ($group_name, $key)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.RE
.RS 4
.PD
.Sp
Retrieves a string value from \f(CW$key\fR inside \f(CW$group_name\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "list = $key_file\fP\->\fBget_string_list\fP ($group_name, \f(CW$key)"
.el .Sh "list = \f(CW$key_file\fP\->\fBget_string_list\fP ($group_name, \f(CW$key\fP)"
.IX Subsection "list = $key_file->get_string_list ($group_name, $key)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.RE
.RS 4
.PD
.Sp
Retrieves a list of strings from \f(CW$key\fR inside \f(CW$group_name\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$key_file\->\fBset_string_list\fP ($group_name, $key, ...)"
.el .Sh "$key_file\->\fBset_string_list\fP ($group_name, \f(CW$key\fP, ...)"
.IX Subsection "$key_file->set_string_list ($group_name, $key, ...)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.IP "* ... (list) list of strings" 4
.IX Item "... (list) list of strings"
.RE
.RS 4
.PD
.Sp
Sets a list of strings in \f(CW$key\fR inside \f(CW$group_name\fR.  The strings will be escaped
if contain special characters.  If \f(CW$key\fR cannot be found then it is created.  If
\&\f(CW$group_name\fR cannot be found then it is created.
.RE
.ie n .Sh "$key_file\->\fBset_string\fP ($group_name, $key\fP, \f(CW$value)"
.el .Sh "$key_file\->\fBset_string\fP ($group_name, \f(CW$key\fP, \f(CW$value\fP)"
.IX Subsection "$key_file->set_string ($group_name, $key, $value)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.ie n .IP "* $value (string)" 4
.el .IP "* \f(CW$value\fR (string)" 4
.IX Item "$value (string)"
.RE
.RS 4
.PD
.Sp
Sets a string value to \f(CW$key\fR inside \f(CW$group_name\fR.  The string will be escaped if
it containes special characters.
If \f(CW$key\fR is not found, it is created.
.RE
.ie n .Sh "string = $key_file\fP\->\fBto_data"
.el .Sh "string = \f(CW$key_file\fP\->\fBto_data\fP"
.IX Subsection "string = $key_file->to_data"
.RS 4
Returns the key file as a string.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "string = $key_file\fP\->\fBget_value\fP ($group_name, \f(CW$key)"
.el .Sh "string = \f(CW$key_file\fP\->\fBget_value\fP ($group_name, \f(CW$key\fP)"
.IX Subsection "string = $key_file->get_value ($group_name, $key)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.RE
.RS 4
.PD
.Sp
Retrieves the literal value of \f(CW$key\fR inside \f(CW$group_name\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$key_file\->\fBset_value\fP ($group_name, $key\fP, \f(CW$value)"
.el .Sh "$key_file\->\fBset_value\fP ($group_name, \f(CW$key\fP, \f(CW$value\fP)"
.IX Subsection "$key_file->set_value ($group_name, $key, $value)"
.RS 4
.ie n .IP "* $group_name (string)" 4
.el .IP "* \f(CW$group_name\fR (string)" 4
.IX Item "$group_name (string)"
.PD 0
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.ie n .IP "* $value (string)" 4
.el .IP "* \f(CW$value\fR (string)" 4
.IX Item "$value (string)"
.RE
.RS 4
.PD
.Sp
Sets the literal value of \f(CW$key\fR inside \f(CW$group_name\fR.
If \f(CW$key\fR cannot be found, it is created.
If \f(CW$group_name\fR cannot be found, it is created.
.RE
.SH "ENUMS AND FLAGS"
.IX Header "ENUMS AND FLAGS"
.Sh "flags Glib::KeyFileFlags"
.IX Subsection "flags Glib::KeyFileFlags"
.IP "* 'none' / 'G_KEY_FILE_NONE'" 4
.IX Item "'none' / 'G_KEY_FILE_NONE'"
.PD 0
.IP "* 'keep\-comments' / 'G_KEY_FILE_KEEP_COMMENTS'" 4
.IX Item "'keep-comments' / 'G_KEY_FILE_KEEP_COMMENTS'"
.IP "* 'keep\-translations' / 'G_KEY_FILE_KEEP_TRANSLATIONS'" 4
.IX Item "'keep-translations' / 'G_KEY_FILE_KEEP_TRANSLATIONS'"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Glib
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2003\-2006 by the gtk2\-perl team.
.PP
This software is licensed under the \s-1LGPL\s0.  See Glib for a full notice.
