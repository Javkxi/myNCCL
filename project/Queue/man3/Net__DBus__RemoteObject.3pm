.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::DBus::RemoteObject 3pm"
.TH Net::DBus::RemoteObject 3pm "2006-11-05" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Net::DBus::RemoteObject \- Access objects provided on the bus
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  my $service = $bus\->get_service("org.freedesktop.DBus");
\&  my $object = $service\->get_object("/org/freedesktop/DBus");
.Ve
.PP
.Vb 5
\&  print "Names on the bus {\en";
\&  foreach my $name (sort $object\->ListNames) {
\&      print "  ", $name, "\en";
\&  }
\&  print "}\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides the \s-1API\s0 for accessing remote objects available
on the bus. It uses the autoloader to fake the presence of methods
based on the \s-1API\s0 of the remote object. There is also support for
setting callbacks against signals, and accessing properties of the
object.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "my $object\fR = Net::DBus::RemoteObject\->new($service, \f(CW$object_path\fR[, \f(CW$interface]);" 4
.el .IP "my \f(CW$object\fR = Net::DBus::RemoteObject\->new($service, \f(CW$object_path\fR[, \f(CW$interface\fR]);" 4
.IX Item "my $object = Net::DBus::RemoteObject->new($service, $object_path[, $interface]);"
Creates a new handle to a remote object. The \f(CW$service\fR parameter is an instance
of the Net::DBus::RemoteService method, and \f(CW$object_path\fR is the identifier of
an object exported by this service, for example \f(CW\*(C`/org/freedesktop/DBus\*(C'\fR. For remote
objects which implement more than one interface it is possible to specify an optional
name of an interface as the third parameter. This is only really required, however, if
two interfaces in the object provide methods with the same name, since introspection
data can be used to automatically resolve the correct interface to call cases where
method names are unique. Rather than using this constructor directly, it is preferrable
to use the \f(CW\*(C`get_object\*(C'\fR method on Net::DBus::RemoteService, since this caches handles
to remote objects, eliminating unneccessary introspection data lookups.
.ie n .IP "my $object\fR = \f(CW$object\->as_interface($interface);" 4
.el .IP "my \f(CW$object\fR = \f(CW$object\fR\->as_interface($interface);" 4
.IX Item "my $object = $object->as_interface($interface);"
Casts the object to a specific interface, returning a new instance of the
Net::DBus::RemoteObject specialized to the desired interface. It is only
neccessary to cast objects to a specific interface, if two interfaces
export methods or signals with the same name, or the remote object does not
support introspection.
.ie n .IP "my $service\fR = \f(CW$object\->get_service" 4
.el .IP "my \f(CW$service\fR = \f(CW$object\fR\->get_service" 4
.IX Item "my $service = $object->get_service"
Retrieves a handle for the remote service on which this object is
attached. The returned object is an instance of Net::DBus::RemoteService
.ie n .IP "my $path\fR = \f(CW$object\->get_object_path" 4
.el .IP "my \f(CW$path\fR = \f(CW$object\fR\->get_object_path" 4
.IX Item "my $path = $object->get_object_path"
Retrieves the unique path identifier for this object within the
service.
.ie n .IP "my $object\fR = \f(CW$object\->get_child_object($subpath, [$interface])" 4
.el .IP "my \f(CW$object\fR = \f(CW$object\fR\->get_child_object($subpath, [$interface])" 4
.IX Item "my $object = $object->get_child_object($subpath, [$interface])"
Retrieves a handle to a child of this object, identified
by the relative path \f(CW$subpath\fR. The returned object
is an instance of \f(CW\*(C`Net::DBus::RemoteObject\*(C'\fR. The optional
\&\f(CW$interface\fR parameter can be used to immediately cast
the object to a specific type.
.ie n .IP "$object\->connect_to_signal($name, $coderef);" 4
.el .IP "$object\->connect_to_signal($name, \f(CW$coderef\fR);" 4
.IX Item "$object->connect_to_signal($name, $coderef);"
Connects a callback to a signal emitted by the object. The \f(CW$name\fR
parameter is the name of the signal within the object, and \f(CW$coderef\fR
is a reference to an anonymous subroutine. When the signal \f(CW$name\fR
is emitted by the remote object, the subroutine \f(CW$coderef\fR will be
invoked, and passed the parameters from the signal.
.SH "AUTHOR"
.IX Header "AUTHOR"
Daniel Berrange <dan@berrange.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copright (C) 2004\-2005, Daniel Berrange.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::DBus::RemoteService, Net::DBus::Object
