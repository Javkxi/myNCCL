.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GenPod 3pm"
.TH GenPod 3pm "2007-03-05" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Glib::GenPod \- POD generation utilities for Glib\-based modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Glib::GenPod;
.Ve
.PP
.Vb 2
\& # use the defaults:
\& xsdoc2pod ($xsdocparse_output_file, $destination_dir);
.Ve
.PP
.Vb 6
\& # or take matters into your own hands
\& require $xsdocparse_output_file;
\& foreach my $package (sort keys %$data) {
\&     print "=head1 NAME\en\en$package\en\en";
\&     print "=head1 METHODS\en\en" . podify_methods ($package) . "\en\en";
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module includes several utilities for creating pod for xs-based Perl
modules which build on the Glib module's foundations.  The most important bits
are the logic to convert the data structures created by xsdocparse.pl to
describe xsubs and pods into method docs, with call signatures and argument
descriptions, and converting C type names into Perl type names.  The rest of
the module is mostly boiler-plate code to format and pretty-print information
that may be queried from the Glib type system.
.PP
To make life easy for module maintainers, we also include a do-it-all function,
\&\fIxsdoc2pod()\fR, which does pretty much everything for you.  All of the pieces it
uses are publically usable, so you can do whatever you like if you don't like
the default output.
.SH "DOCUMENTING THE XS FILES"
.IX Header "DOCUMENTING THE XS FILES"
All of the information used as input to the methods included here comes from
the \s-1XS\s0 files of your project, and is extracted by Glib::ParseXSDoc's
\&\f(CW\*(C`xsdocparse\*(C'\fR.  This function creates an file containing Perl code that may be
eval'd or require'd to recreate the parsed data structures, which are a list of
pods from the verbatim C portion of the \s-1XS\s0 file (the xs api docs), and a hash
of the remaining data, keyed by package name, and including the pods and xsubs
read from the rest of each \s-1XS\s0 file following the first \s-1MODULE\s0 line.
.PP
Several custom \s-1POD\s0 directives are recognized in the XSubs section.  Note that
each one is sought as a paragraph starter, and must follow a \f(CW\*(C`=cut\*(C'\fR directive.
.IP "=for object Package::Name" 4
.IX Item "=for object Package::Name"
All xsubs and pod from here until the next object directive or \s-1MODULE\s0 line
will be placed under the key '\fIPackage::Name\fR' in xsdocparse's data
structure.  Everything from this line to the next \f(CW\*(C`=cut\*(C'\fR is included as a
description \s-1POD\s0.
.IP "=for enum Package::Name" 4
.IX Item "=for enum Package::Name"
.PD 0
.IP "=for flags Package::Name" 4
.IX Item "=for flags Package::Name"
.PD
This causes xsdoc2pod to call \f(CW\*(C`podify_values\*(C'\fR on \fIPackage::Name\fR when
writing the pod for the current package (as set by an object directive or
\&\s-1MODULE\s0 line).  Any text in this paragraph, to the next \f(CW\*(C`=cut\*(C'\fR, is included
in that section.
.IP "=for see_also some_thing_to_see" 4
.IX Item "=for see_also some_thing_to_see"
Used to add extra see alsos onto the end of the parents, if any, for a given
object.  Anything following the space behind see_also up to the end of the
line will be placed onto the list of \*(L"see also\*(R"s.  There may be any number of
these in each package.
.IP "=for apidoc" 4
.IX Item "=for apidoc"
.PD 0
.IP "=for apidoc Full::Symbol::name" 4
.IX Item "=for apidoc Full::Symbol::name"
.PD
Paragraphs of this type document xsubs, and are associated with the xsubs
by xsdocparse.pl.  If the full symbol name is not included, the paragraph
must be attached to the xsub declaration (no blank lines between \f(CW\*(C`=cut\*(C'\fR and
the xsub).
.Sp
Within the apidoc PODs, we recognize a few special directives (the \*(L"for\es+\*(R"
is optional on these):
.RS 4
.IP "=for signature ..." 4
.IX Item "=for signature ..."
Override the generated call signature with the ... text.  If you include
multiple signature directives, they will all be used.  This is handy when
you want to change the return type or list different ways to invoke an
overloaded method, like this:
.Sp
.Vb 1
\& =for apidoc
.Ve
.Sp
.Vb 1
\& =signature bool Class\->foo
.Ve
.Sp
.Vb 1
\& =signature ($thing, @other) = $object\->foo ($it, $something)
.Ve
.Sp
.Vb 4
\& Text in here is included in the generated documentation.
\& You can actually include signature and arg directives
\& at any point in this pod \-\- they are stripped after.
\& In fact, any pod is valid in here, until the =cut.
.Ve
.Sp
.Vb 4
\& =cut
\& void foo (...)
\&     PPCODE:
\&        /* crazy code follows */
.Ve
.IP "=for arg name (type) description" 4
.IX Item "=for arg name (type) description"
.PD 0
.IP "=for arg name description" 4
.IX Item "=for arg name description"
.PD
The arg directive adds or overrides an argument description.  The
description text is optional, as is the type specification (the part
in parentheses).  The arg name does \fInot\fR need to include a sigil,
as dollar signs will be added.  \s-1FIXME\s0 what about @ for lists?
.RE
.RS 4
.Sp
Also, we honor a couple of \*(L"modifiers\*(R" on the =for apidoc line, following the
symbol name, if present:
.IP "\- _\|_hide_\|_" 4
.IX Item "- __hide__"
Do not document this xsub.  This is handy in certain situations, e.g., for
private functions.  \s-1DESTROY\s0 always has this turned on, for example.
.IP "\- _\|_gerror_\|_" 4
.IX Item "- __gerror__"
This function or method can generate a Glib::Error exception.
.IP "\- _\|_function_\|_" 4
.IX Item "- __function__"
Generate a function-style signature for this xsub.  The default is to
generate method-style signatures.
.RE
.RS 4
.Sp
(These are actually handled by Glib::ParseXSDoc, but we list them here
because, well, they're an important part of how you document the \s-1XS\s0 files.)
.RE
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP "xsdoc2pod ($datafile, $outdir='blib/lib', index=undef)" 4
.el .IP "xsdoc2pod ($datafile, \f(CW$outdir\fR='blib/lib', index=undef)" 4
.IX Item "xsdoc2pod ($datafile, $outdir='blib/lib', index=undef)"
Given a \fI$datafile\fR containing the output of xsdocparse.pl, create in 
\&\fI$outdir\fR a pod file for each package, containing everything we can think
of for that module.  Output is controlled by the \f(CW\*(C`=for object\*(C'\fR directives
and such in the source code.
.Sp
If you don't want each package to create a separate pod file, then use
this function's code as a starting point for your own pretty\-printer.
.IP "add_types (@filenames)" 4
.IX Item "add_types (@filenames)"
Parse the given \fI@filenames\fR for entries to add to the \f(CW%basic_types\fR used
for C type name to Perl package name mappings of types that are not registered
with the Glib type system.  The file format is dead simple: blank lines are
ignored; /#.*$/ is stripped from each line as comments; the first token on
each line is considered to be a C type name, and the remaining tokens are the
description of that type.  For example, a valid file may look like this:
.Sp
.Vb 3
\&  # a couple of special types
\&  FooBar      Foo::Bar
\&  Frob        localized frobnicator
.Ve
.Sp
C type decorations such as \*(L"const\*(R" and \*(L"*\*(R" are implied (do not include them),
and the _ornull variant is handled for you.
.IP "$string = podify_properties ($packagename)" 4
.IX Item "$string = podify_properties ($packagename)"
Pretty-print the object properties owned by the Glib::Object derivative
\&\fI$packagename\fR and return the text as a string.  Returns undef if there
are no properties or \fI$package\fR is not a Glib::Object.
.IP "$string = podify_values ($packagename)" 4
.IX Item "$string = podify_values ($packagename)"
List and pretty-print the values of the GEnum or GFlags type \fI$packagename\fR,
and return the text as a string.  Returns undef if \fI$packagename\fR isn't an
enum or flags type.
.IP "$string = podify_signals ($packagename)" 4
.IX Item "$string = podify_signals ($packagename)"
Query, list, and pretty-print the signals associated with \fI$packagename\fR.
Returns the text as a string, or undef if there are no signals or
\&\fI$packagename\fR is not a Glib::Object derivative.
.ie n .IP "$string = podify_pods ($pods, $position)" 4
.el .IP "$string = podify_pods ($pods, \f(CW$position\fR)" 4
.IX Item "$string = podify_pods ($pods, $position)"
Helper function to allow specific placement of generic pod within the auto
generated pages. Pod sections starting out with =for position \s-1XXX\s0, where \s-1XXX\s0
is one of the following will be placed at a specified position. In the case of
pod that is to be placed after a particular section that doesn't exist, that
pod will be still be placed there.
.Sp
This function is called at all of the specified points through out the process
of generating pod for a page. Any pod matching the \fIposition\fR passed will be
returned, undef if no matches were found.  If \fIposition\fR is undef all pods
without sepcific postion information will be returned. \fIpods\fR is a reference
to an array of pod hashes.
.RS 4
.IP "* \s-1SYNOPSIS\s0" 4
.IX Item "SYNOPSIS"
After the \s-1NAME\s0 section
.IP "* \s-1DESCRIPTION\s0" 4
.IX Item "DESCRIPTION"
After the \s-1SYNOPSIS\s0 section.
.IP "* post_hierarchy" 4
.IX Item "post_hierarchy"
After the \s-1HIERARCHY\s0 section.
.IP "* post_interfaces" 4
.IX Item "post_interfaces"
After the \s-1INTERFACE\s0 section.
.IP "* post_methods" 4
.IX Item "post_methods"
After the \s-1METHODS\s0 section.
.IP "* post_properties" 4
.IX Item "post_properties"
After the \s-1PROPERTIES\s0 section.
.IP "* post_signals" 4
.IX Item "post_signals"
After the \s-1SIGNALS\s0 section.
.IP "* post_enums" 4
.IX Item "post_enums"
After the \s-1ENUMS\s0 \s-1AND\s0 \s-1FLAGS\s0 section.
.IP "* \s-1SEE_ALSO\s0" 4
.IX Item "SEE_ALSO"
Replacing the autogenerated \s-1SEE\s0 \s-1ALSO\s0 section completely.
.IP "* \s-1COPYRIGHT\s0" 4
.IX Item "COPYRIGHT"
Replacing the autogenerated \s-1COPYRIGHT\s0 section completely.
.RE
.RS 4
.RE
.IP "$string = podify_ancestors ($packagename)" 4
.IX Item "$string = podify_ancestors ($packagename)"
Pretty-prints the ancestry of \fI$packagename\fR from the Glib type system's
point of view.  This uses Glib::Type\->list_ancestors; see that function's
docs for an explanation of why that's different from looking at \f(CW@ISA\fR.
.Sp
Returns the new text as a string, or undef if \fI$packagename\fR is not a
registered GType.
.IP "$string = podify_interfaces ($packagename)" 4
.IX Item "$string = podify_interfaces ($packagename)"
Pretty-print the list of GInterfaces that \fI$packagename\fR implements.
Returns the text as a string, or undef if the type implements no interfaces.
.IP "$string = podify_methods ($packagename)" 4
.IX Item "$string = podify_methods ($packagename)"
Call \f(CW\*(C`xsub_to_pod\*(C'\fR on all the xsubs under the key \fI$packagename\fR in the
data extracted by xsdocparse.pl.
.Sp
Returns the new text as a string, or undef if there are no xsubs in
\&\fI$packagename\fR.
.IP "$string = podify_see_alsos (@entries)" 4
.IX Item "$string = podify_see_alsos (@entries)"
Creates a list of links to be placed in the \s-1SEE\s0 \s-1ALSO\s0 section of the page.
Returns undef if nothing is in the input list.
.IP "$string = get_copyright" 4
.IX Item "$string = get_copyright"
Returns a string that will/should be placed on each page.  You can control
the text of this string by setting the package variable \f(CW$COPYRIGHT\fR to
whatever you like.
.Sp
If \f(CW$COPYRIGHT\fR is not set, we will attempt to create one for you, using the
values of the variables \f(CW$YEAR\fR, \f(CW$AUTHOR\fR, and \f(CW$MAIN_MOD\fR.  \f(CW$YEAR\fR defaults to
the current year, \f(CW$AUTHORS\fR defaults to 'The Gtk2\-Perl Team', and \f(CW$MAIN_MOD\fR
defaults to empty.  You want \f(CW$MAIN_MOD\fR to be set to the main module of your
extension for the \s-1SEE\s0 \s-1ALSO\s0 section, and on the assumption that a decent
license notice can be found in that module's doc, we point the reader there.
.Sp
So, in general, you will want to specify at least one of these, so that you
don't credit your work to us under the \s-1LGPL\s0.
.Sp
To set \f(CW$COPYRIGHT\fR, \f(CW$AUTHORS\fR, and/or \f(CW$MAIN_MOD\fR do something similar to the
following in the first part of your postamble section in Makefile.PL.  All of
the weird escaping is required because this is going through several levels of
variable expansion.  All occurences of <br> in \f(CW$COPYRIGHT\fR are replaced with
newlines, to make it easier to put in a multi-line string.
.Sp
.Vb 1
\&  POD_SET=\e\e\e$\e$Glib::GenPod::COPYRIGHT='Copyright 1999 team\-foobar<br>LGPL';
.Ve
.Sp
\&\fIGlib::MakeHelper::postamble_docs_full()\fR does this sort of thing for you.
.Sh "Helpers"
.IX Subsection "Helpers"
.IP "$perl_type = convert_type ($ctypestring)" 4
.IX Item "$perl_type = convert_type ($ctypestring)"
Convert a C type name to a Perl type name.
.Sp
Uses \f(CW%Glib::GenPod::basic_types\fR to look for some known basic types,
and uses Glib::Type\->package_from_cname to look up the registered
package corresponding to a C type name.  If no suitable mapping can
be found, this just returns the input string.
.ie n .IP "$string = xsub_to_pod ($xsub, $sigprefix='')" 4
.el .IP "$string = xsub_to_pod ($xsub, \f(CW$sigprefix\fR='')" 4
.IX Item "$string = xsub_to_pod ($xsub, $sigprefix='')"
Convert an xsub hash into a string of pod describing it.  Includes the
call signature, argument listing, and description, honoring special
switches in the description pod (arg and signature overrides).
.IP "$string = compile_signature ($xsub)" 4
.IX Item "$string = compile_signature ($xsub)"
Given an xsub hash, return a string with the call signature for that
xsub.
.IP "$string = fixup_arg_name ($name)" 4
.IX Item "$string = fixup_arg_name ($name)"
Prepend a $ to anything that's not the literal ellipsis string '...'.
.IP "fixup_default" 4
.IX Item "fixup_default"
Mangle default parameter values from C to Perl values.  Mostly, this
does \s-1NULL\s0 => undef.
.IP "convert_arg_type" 4
.IX Item "convert_arg_type"
C type to Perl type conversion for argument types.
.IP "convert_return_type_to_name" 4
.IX Item "convert_return_type_to_name"
C type to Perl type conversion suitable for return types.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Glib::ParseXSDoc
.SH "AUTHORS"
.IX Header "AUTHORS"
muppet bashed out the xsub signature generation in a few hours on a wednesday
night when band practice was cancelled at the last minute; he and ross
mcfarland hacked this module together via irc and email over the next few days.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2003\-2004 by the gtk2\-perl team
.PP
This library is free software; you can redistribute it and/or modify
it under the terms of the Lesser General Public License (\s-1LGPL\s0).  For 
more information, see http://www.fsf.org/licenses/lgpl.txt
