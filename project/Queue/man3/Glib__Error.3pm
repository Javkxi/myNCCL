.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Glib::Error 3pm"
.TH Glib::Error 3pm "2007-03-05" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Glib::Error \-  Exception Objects based on GError
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 16
\&  eval {
\&     my $pixbuf = Gtk2::Gdk::Pixbuf\->new_from_file ($filename);
\&     $image\->set_from_pixbuf ($pixbuf);
\&  };
\&  if ($@) {
\&     print "$@\en";
\&     if (Glib::Error::matches ($@, 'Gtk2::Gdk::Pixbuf::Error',
\&                                   'unknown\-format')) {
\&        change_format_and_try_again ();
\&     } elsif (Glib::Error::matches ($@, 'Glib::File::Error', 'noent')) {
\&        change_source_dir_and_try_again ();
\&     } else {
\&        # don't know how to handle this
\&        die $@;
\&     }
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Gtk2\-Perl translates GLib's GError runtime errors into Perl exceptions, by
creating exception objects based on Glib::Error.  Glib::Error overloads the
stringification operator, so a Glib::Error object will act like a string if
used with \fIprint()\fR or \fIwarn()\fR, so most code using $@ will not even know the
difference.
.PP
The point of having exception objects, however, is that the error messages
in GErrors are often localized with \s-1NLS\s0 translation.  Thus, it's not good
for your code to attempt to handle errors by string matching on the the 
error message.  Glib::Error provides a way to get to the deterministic
error code.
.PP
You will typically deal with objects that inherit from Glib::Error, such as
Glib::Convert::Error, Glib::File::Error, Gtk2::Gdk::Pixbuf::Error, etc; these
classes are provided by the libraries that define the error domains.  However,
it is possible to get a base Glib::Error when the bindings encounter an unknown
or unbound error domain.  The interface used here degrades nicely in such a
situation, but in general you should submit a bug report to the binding
maintainer if you get such an exception.
.SH "METHODS"
.IX Header "METHODS"
.ie n .Sh "scalar = Glib::Error::new ($class, $code\fP, \f(CW$message)"
.el .Sh "scalar = Glib::Error::new ($class, \f(CW$code\fP, \f(CW$message\fP)"
.IX Subsection "scalar = Glib::Error::new ($class, $code, $message)"
.ie n .Sh "scalar = $class\fP\->\fBnew\fP ($code, \f(CW$message)"
.el .Sh "scalar = \f(CW$class\fP\->\fBnew\fP ($code, \f(CW$message\fP)"
.IX Subsection "scalar = $class->new ($code, $message)"
.RS 4
.ie n .IP "* $code\fR (GEnum) an enumeration value, depends on \fI$class" 4
.el .IP "* \f(CW$code\fR (GEnum) an enumeration value, depends on \fI$class\fR" 4
.IX Item "$code (GEnum) an enumeration value, depends on $class"
.PD 0
.ie n .IP "* $message (string)" 4
.el .IP "* \f(CW$message\fR (string)" 4
.IX Item "$message (string)"
.RE
.RS 4
.PD
.Sp
Create a new exception object of type \fI$class\fR, where \fI$class\fR is associated
with a GError domain.  \fI$code\fR should be a value from the enumeration type
associated with this error domain.  \fI$message\fR can be anything you like, but
should explain what happened from the point of view of a user.
.RE
.ie n .Sh "integer = $error\fP\->\fBcode"
.el .Sh "integer = \f(CW$error\fP\->\fBcode\fP"
.IX Subsection "integer = $error->code"
.RS 4
This is the numeric error code.  Normally, you'll want to use \f(CW\*(C`value\*(C'\fR instead,
for readability.
.RE
.ie n .Sh "string = $error\fP\->\fBdomain"
.el .Sh "string = \f(CW$error\fP\->\fBdomain\fP"
.IX Subsection "string = $error->domain"
.RS 4
The error domain.  You normally do not need this, as the object will be blessed
into a corresponding class.
.RE
.ie n .Sh "string = $error\fP\->\fBlocation"
.el .Sh "string = \f(CW$error\fP\->\fBlocation\fP"
.IX Subsection "string = $error->location"
.RS 4
The source line and file closest to the emission of the exception, in the same
format that you'd get from \fIcroak()\fR or \fIdie()\fR.
.RE
.ie n .Sh "boolean = $error\fP\->\fBmatches\fP ($domain, \f(CW$code)"
.el .Sh "boolean = \f(CW$error\fP\->\fBmatches\fP ($domain, \f(CW$code\fP)"
.IX Subsection "boolean = $error->matches ($domain, $code)"
.RS 4
.ie n .IP "* $domain (string)" 4
.el .IP "* \f(CW$domain\fR (string)" 4
.IX Item "$domain (string)"
.PD 0
.ie n .IP "* $code (scalar)" 4
.el .IP "* \f(CW$code\fR (scalar)" 4
.IX Item "$code (scalar)"
.RE
.RS 4
.PD
.Sp
Returns true if the exception in \fI$error\fR matches the given \fI$domain\fR and
\&\fI$code\fR.  \fI$domain\fR may be a class name or domain quark (that is, the real
string used in C).  \fI$code\fR may be an integer value or an enum nickname;
the enum type depends on the value of \fI$domain\fR.
.RE
.ie n .Sh "string = $error\fP\->\fBmessage"
.el .Sh "string = \f(CW$error\fP\->\fBmessage\fP"
.IX Subsection "string = $error->message"
.RS 4
The error message.  This may be localized, as it is intended to be shown to a
user.
.RE
.ie n .Sh "Glib::Error::register ($package, $enum_package)"
.el .Sh "Glib::Error::register ($package, \f(CW$enum_package\fP)"
.IX Subsection "Glib::Error::register ($package, $enum_package)"
.RS 4
.ie n .IP "* $package (string) class name to register as a Glib::Error." 4
.el .IP "* \f(CW$package\fR (string) class name to register as a Glib::Error." 4
.IX Item "$package (string) class name to register as a Glib::Error."
.PD 0
.ie n .IP "* $enum_package (string) class name of the enum type to use for this domain's error codes." 4
.el .IP "* \f(CW$enum_package\fR (string) class name of the enum type to use for this domain's error codes." 4
.IX Item "$enum_package (string) class name of the enum type to use for this domain's error codes."
.RE
.RS 4
.PD
.Sp
Register a new error domain.  Glib::Error will be added @\fIpackage\fR::ISA for
you.  \fIenum_package\fR must be a valid Glib::Enum type, either from a C library
or registered with \f(CW\*(C`Glib::Type::register_enum\*(C'\fR.  After registering an
error domain, you can create or throw exceptions of this type.
.RE
.ie n .Sh "scalar = Glib::Error::throw ($class, $code\fP, \f(CW$message)"
.el .Sh "scalar = Glib::Error::throw ($class, \f(CW$code\fP, \f(CW$message\fP)"
.IX Subsection "scalar = Glib::Error::throw ($class, $code, $message)"
.ie n .Sh "scalar = $class\fP\->\fBthrow\fP ($code, \f(CW$message)"
.el .Sh "scalar = \f(CW$class\fP\->\fBthrow\fP ($code, \f(CW$message\fP)"
.IX Subsection "scalar = $class->throw ($code, $message)"
.RS 4
.ie n .IP "* $code\fR (GEnum) an enumeration value, depends on \fI$class" 4
.el .IP "* \f(CW$code\fR (GEnum) an enumeration value, depends on \fI$class\fR" 4
.IX Item "$code (GEnum) an enumeration value, depends on $class"
.PD 0
.ie n .IP "* $message (string)" 4
.el .IP "* \f(CW$message\fR (string)" 4
.IX Item "$message (string)"
.RE
.RS 4
.PD
.Sp
Throw an exception with a Glib::Error exception object.
Equivalent to \f(CW\*(C`croak (Glib::Error::new ($class, $code, $message));\*(C'\fR.
.RE
.ie n .Sh "string = $error\fP\->\fBvalue"
.el .Sh "string = \f(CW$error\fP\->\fBvalue\fP"
.IX Subsection "string = $error->value"
.RS 4
The enumeration value nickname of the integer value in \f(CW\*(C`$error\->code\*(C'\fR, 
according to this error domain.  This will not be available if the error
object is a base Glib::Error, because the bindings will have no idea how to
get to the correct nickname.
.RE
.SH "ENUMS AND FLAGS"
.IX Header "ENUMS AND FLAGS"
.Sh "enum GEnum"
.IX Subsection "enum GEnum"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Glib
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2003\-2006 by the gtk2\-perl team.
.PP
This software is licensed under the \s-1LGPL\s0.  See Glib for a full notice.
