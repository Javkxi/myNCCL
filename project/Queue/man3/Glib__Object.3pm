.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Glib::Object 3pm"
.TH Glib::Object 3pm "2007-03-05" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Glib::Object \-  Bindings for GObject
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
GObject is the base object class provided by the gobject library.  It provides
object properties with a notification system, and emittable signals.
.PP
Glib::Object is the corresponding Perl object class.  Glib::Objects are
represented by blessed hash references, with a magical connection to the
underlying C object.
.SH "HIERARCHY"
.IX Header "HIERARCHY"
.Vb 1
\&  Glib::Object
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .Sh "object = $class\fP\->\fBnew (...)"
.el .Sh "object = \f(CW$class\fP\->\fBnew\fP (...)"
.IX Subsection "object = $class->new (...)"
.RS 4
.IP "* ... (list) of key/value pairs, property values to set on creation" 4
.IX Item "... (list) of key/value pairs, property values to set on creation"
.RE
.RS 4
.Sp
Instantiate a Glib::Object of type \fI$class\fR.  Any key/value pairs in
\&\fI...\fR are used to set properties on the new object; see \f(CW\*(C`set\*(C'\fR.
This is designed to be inherited by Perl-derived subclasses (see
Glib::Object::Subclass), but you can actually use it to create
any GObject-derived type.
.RE
.ie n .Sh "scalar = Glib::Object\->\fBnew_from_pointer\fP ($pointer, $noinc=FALSE)"
.el .Sh "scalar = Glib::Object\->\fBnew_from_pointer\fP ($pointer, \f(CW$noinc\fP=FALSE)"
.IX Subsection "scalar = Glib::Object->new_from_pointer ($pointer, $noinc=FALSE)"
.RS 4
.ie n .IP "* $pointer (unsigned) a C pointer value as an integer." 4
.el .IP "* \f(CW$pointer\fR (unsigned) a C pointer value as an integer." 4
.IX Item "$pointer (unsigned) a C pointer value as an integer."
.PD 0
.ie n .IP "* $noinc (boolean) if true, do not increase the GObject's reference count when creating the Perl wrapper.  this typically means that when the Perl wrapper will own the object.  in general you don't want to do that, so the default is false." 4
.el .IP "* \f(CW$noinc\fR (boolean) if true, do not increase the GObject's reference count when creating the Perl wrapper.  this typically means that when the Perl wrapper will own the object.  in general you don't want to do that, so the default is false." 4
.IX Item "$noinc (boolean) if true, do not increase the GObject's reference count when creating the Perl wrapper.  this typically means that when the Perl wrapper will own the object.  in general you don't want to do that, so the default is false."
.RE
.RS 4
.PD
.Sp
Create a Perl Glib::Object reference for the C object pointed to by \fI$pointer\fR.
You should need this \fIvery\fR rarely; it's intended to support foreign objects.
.Sp
\&\s-1NOTE:\s0 the cast from arbitrary integer to GObject may result in a core dump without
warning, because the type-checking macro \fIG_OBJECT()\fR attempts to dereference the
pointer to find a GTypeClass structure, and there is no portable way to validate
the pointer.
.RE
.ie n .Sh "unsigned = $object\fP\->\fBget_data ($key)"
.el .Sh "unsigned = \f(CW$object\fP\->\fBget_data\fP ($key)"
.IX Subsection "unsigned = $object->get_data ($key)"
.RS 4
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.RE
.RS 4
.Sp
Fetch the integer stored under the object data key \fI$key\fR.  These values do not
have types; type conversions must be done manually.  See \f(CW\*(C`set_data\*(C'\fR.
.RE
.ie n .Sh "$object\->\fBset_data\fP ($key, $data)"
.el .Sh "$object\->\fBset_data\fP ($key, \f(CW$data\fP)"
.IX Subsection "$object->set_data ($key, $data)"
.RS 4
.ie n .IP "* $key (string)" 4
.el .IP "* \f(CW$key\fR (string)" 4
.IX Item "$key (string)"
.PD 0
.ie n .IP "* $data (scalar)" 4
.el .IP "* \f(CW$data\fR (scalar)" 4
.IX Item "$data (scalar)"
.RE
.RS 4
.PD
.Sp
GObject provides an arbitrary data mechanism that assigns unsigned integers
to key names.  Functionality overlaps with the hash used as the Perl object
instance, so we strongly recommend you use hash keys for your data storage.
The GObject data values cannot store type information, so they are not safe
to use for anything but integer values, and you really should use this method
only if you know what you are doing.
.RE
.ie n .Sh "pspec = $object_or_class_name\fP\->\fBfind_property ($name)"
.el .Sh "pspec = \f(CW$object_or_class_name\fP\->\fBfind_property\fP ($name)"
.IX Subsection "pspec = $object_or_class_name->find_property ($name)"
.RS 4
.ie n .IP "* $name (string)" 4
.el .IP "* \f(CW$name\fR (string)" 4
.IX Item "$name (string)"
.RE
.RS 4
.Sp
Find the definition of object property \fI$name\fR for \fI$object_or_class_name\fR; for
the returned data see Glib::Object::list_properties.
.RE
.Sh "$object\->\fBfreeze_notify\fP"
.IX Subsection "$object->freeze_notify"
.RS 4
Stops emission of \*(L"notify\*(R" signals on \fI$object\fR. The signals are queued
until \f(CW\*(C`thaw_notify\*(C'\fR is called on \fI$object\fR.
.RE
.ie n .Sh "list = $object\fP\->\fBget (...)"
.el .Sh "list = \f(CW$object\fP\->\fBget\fP (...)"
.IX Subsection "list = $object->get (...)"
.RS 4
.IP "* ... (list) list of property names" 4
.IX Item "... (list) list of property names"
.RE
.RS 4
.Sp
Fetch and return the values for the object properties named in \fI...\fR.
.RE
.ie n .Sh "$object\->\fBset\fP (key => $value, ...)"
.el .Sh "$object\->\fBset\fP (key => \f(CW$value\fP, ...)"
.IX Subsection "$object->set (key => $value, ...)"
.RS 4
.IP "* ... (list)" 4
.IX Item "... (list)"
.RE
.RS 4
.Sp
Set object properties.
.RE
.ie n .Sh "list = $object_or_class_name\fP\->\fBlist_properties"
.el .Sh "list = \f(CW$object_or_class_name\fP\->\fBlist_properties\fP"
.IX Subsection "list = $object_or_class_name->list_properties"
.RS 4
.RE
.RS 4
.Sp
List all the object properties for \fI$object_or_class_name\fR; returns them as
a list of hashes, containing these keys:
.IP "name" 4
.IX Item "name"
The name of the property
.IP "type" 4
.IX Item "type"
The type of the property
.IP "owner_type" 4
.IX Item "owner_type"
The type that owns the property
.IP "descr" 4
.IX Item "descr"
The description of the property
.IP "flags" 4
.IX Item "flags"
The Glib::ParamFlags of the property
.RE
.RS 4
.RE
.Sh "$object\->\fBnotify\fP ($property_name)"
.IX Subsection "$object->notify ($property_name)"
.RS 4
.ie n .IP "* $property_name (string)" 4
.el .IP "* \f(CW$property_name\fR (string)" 4
.IX Item "$property_name (string)"
.RE
.RS 4
.Sp
Emits a \*(L"notify\*(R" signal for the property \fI$property\fR on \fI$object\fR.
.RE
.ie n .Sh "gpointer = $object\fP\->\fBget_pointer"
.el .Sh "gpointer = \f(CW$object\fP\->\fBget_pointer\fP"
.IX Subsection "gpointer = $object->get_pointer"
.RS 4
Complement of \f(CW\*(C`new_from_pointer\*(C'\fR.
.RE
.ie n .Sh "list = $object\fP\->\fBget_property (...)"
.el .Sh "list = \f(CW$object\fP\->\fBget_property\fP (...)"
.IX Subsection "list = $object->get_property (...)"
.RS 4
.RE
.RS 4
.Sp
Alias for \f(CW\*(C`get\*(C'\fR.
.RE
.ie n .Sh "$object\->\fBset_property\fP (key => $value, ...)"
.el .Sh "$object\->\fBset_property\fP (key => \f(CW$value\fP, ...)"
.IX Subsection "$object->set_property (key => $value, ...)"
.RS 4
.RE
.RS 4
.Sp
Alias for \f(CW\*(C`set\*(C'\fR.
.RE
.ie n .Sh "unsigned = $object_or_class_name\fP\->\fBsignal_add_emission_hook\fP ($detailed_signal, \f(CW$hook_func\fP, \f(CW$hook_data=undef)"
.el .Sh "unsigned = \f(CW$object_or_class_name\fP\->\fBsignal_add_emission_hook\fP ($detailed_signal, \f(CW$hook_func\fP, \f(CW$hook_data\fP=undef)"
.IX Subsection "unsigned = $object_or_class_name->signal_add_emission_hook ($detailed_signal, $hook_func, $hook_data=undef)"
.RS 4
.ie n .IP "* $detailed_signal (string) of the form ""signal\-name::detail""" 4
.el .IP "* \f(CW$detailed_signal\fR (string) of the form ``signal\-name::detail''" 4
.IX Item "$detailed_signal (string) of the form signal-name::detail"
.PD 0
.ie n .IP "* $hook_func (subroutine)" 4
.el .IP "* \f(CW$hook_func\fR (subroutine)" 4
.IX Item "$hook_func (subroutine)"
.ie n .IP "* $hook_data (scalar)" 4
.el .IP "* \f(CW$hook_data\fR (scalar)" 4
.IX Item "$hook_data (scalar)"
.RE
.RS 4
.PD
.Sp
Add an emission hook for a signal.  The hook will be called for any emission
of that signal, independent of the instance.  This is possible only for
signals which don't have the \f(CW\*(C`G_SIGNAL_NO_HOOKS\*(C'\fR flag set.
.Sp
The \fI$hook_func\fR should be reference to a subroutine that looks something
like this:
.Sp
.Vb 6
\&  sub emission_hook {
\&      my ($invocation_hint, $parameters, $hook_data) = @_;
\&      # $parameters is a reference to the @_ to be passed to
\&      # signal handlers, including the instance as $parameters\->[0].
\&      return $stay_connected;  # boolean
\&  }
.Ve
.Sp
This function returns an id that can be used with \f(CW\*(C`remove_emission_hook\*(C'\fR.
.Sp
Since 1.100.
.RE
.ie n .Sh "list = $instance\fP\->\fBsignal_chain_from_overridden (...)"
.el .Sh "list = \f(CW$instance\fP\->\fBsignal_chain_from_overridden\fP (...)"
.IX Subsection "list = $instance->signal_chain_from_overridden (...)"
.RS 4
.IP "* ... (list)" 4
.IX Item "... (list)"
.RE
.RS 4
.Sp
Chain up to an overridden class closure; it is only valid to call this from
a class closure override.
.Sp
Translation: because of various details in how GObjects are implemented,
the way to override a virtual method on a GObject is to provide a new \*(L"class
closure\*(R", or default handler for a signal.  This happens when a class is
registered with the type system (see Glib::Type::register and
Glib::Object::Subclass).  When called from inside such an override, this
method runs the overridden class closure.  This is equivalent to calling
\&\f(CW$self\fR\->SUPER::$method (@_) in normal Perl objects.
.RE
.ie n .Sh "unsigned = $instance\fP\->\fBsignal_connect\fP ($detailed_signal, \f(CW$callback\fP, \f(CW$data=undef)"
.el .Sh "unsigned = \f(CW$instance\fP\->\fBsignal_connect\fP ($detailed_signal, \f(CW$callback\fP, \f(CW$data\fP=undef)"
.IX Subsection "unsigned = $instance->signal_connect ($detailed_signal, $callback, $data=undef)"
.RS 4
.ie n .IP "* $detailed_signal (string)" 4
.el .IP "* \f(CW$detailed_signal\fR (string)" 4
.IX Item "$detailed_signal (string)"
.PD 0
.ie n .IP "* $callback (subroutine)" 4
.el .IP "* \f(CW$callback\fR (subroutine)" 4
.IX Item "$callback (subroutine)"
.ie n .IP "* $data\fR (scalar) arbitrary data to be passed to each invocation of \fIcallback" 4
.el .IP "* \f(CW$data\fR (scalar) arbitrary data to be passed to each invocation of \fIcallback\fR" 4
.IX Item "$data (scalar) arbitrary data to be passed to each invocation of callback"
.RE
.RS 4
.PD
.Sp
Register \fIcallback\fR to be called on each emission of \fI$detailed_signal\fR.
Returns an identifier that may be used to remove this handler with
\&\f(CW\*(C`$object\->signal_handler_disconnect\*(C'\fR.
.RE
.ie n .Sh "unsigned = $instance\fP\->\fBsignal_connect_after\fP ($detailed_signal, \f(CW$callback\fP, \f(CW$data=undef)"
.el .Sh "unsigned = \f(CW$instance\fP\->\fBsignal_connect_after\fP ($detailed_signal, \f(CW$callback\fP, \f(CW$data\fP=undef)"
.IX Subsection "unsigned = $instance->signal_connect_after ($detailed_signal, $callback, $data=undef)"
.RS 4
.ie n .IP "* $detailed_signal (string)" 4
.el .IP "* \f(CW$detailed_signal\fR (string)" 4
.IX Item "$detailed_signal (string)"
.PD 0
.ie n .IP "* $callback (scalar)" 4
.el .IP "* \f(CW$callback\fR (scalar)" 4
.IX Item "$callback (scalar)"
.ie n .IP "* $data (scalar)" 4
.el .IP "* \f(CW$data\fR (scalar)" 4
.IX Item "$data (scalar)"
.RE
.RS 4
.PD
.Sp
Like \f(CW\*(C`signal_connect\*(C'\fR, except that \fI$callback\fR will be run after the default
handler.
.RE
.ie n .Sh "unsigned = $instance\fP\->\fBsignal_connect_swapped\fP ($detailed_signal, \f(CW$callback\fP, \f(CW$data=undef)"
.el .Sh "unsigned = \f(CW$instance\fP\->\fBsignal_connect_swapped\fP ($detailed_signal, \f(CW$callback\fP, \f(CW$data\fP=undef)"
.IX Subsection "unsigned = $instance->signal_connect_swapped ($detailed_signal, $callback, $data=undef)"
.RS 4
.ie n .IP "* $detailed_signal (string)" 4
.el .IP "* \f(CW$detailed_signal\fR (string)" 4
.IX Item "$detailed_signal (string)"
.PD 0
.ie n .IP "* $callback (scalar)" 4
.el .IP "* \f(CW$callback\fR (scalar)" 4
.IX Item "$callback (scalar)"
.ie n .IP "* $data (scalar)" 4
.el .IP "* \f(CW$data\fR (scalar)" 4
.IX Item "$data (scalar)"
.RE
.RS 4
.PD
.Sp
Like \f(CW\*(C`signal_connect\*(C'\fR, except that \fI$data\fR and \fI$object\fR will be swapped
on invocation of \fI$callback\fR.
.RE
.ie n .Sh "retval = $object\fP\->\fBsignal_emit ($name, ...)"
.el .Sh "retval = \f(CW$object\fP\->\fBsignal_emit\fP ($name, ...)"
.IX Subsection "retval = $object->signal_emit ($name, ...)"
.RS 4
.ie n .IP "* $name (string) the name of the signal" 4
.el .IP "* \f(CW$name\fR (string) the name of the signal" 4
.IX Item "$name (string) the name of the signal"
.PD 0
.IP "* ... (list) any arguments to pass to handlers." 4
.IX Item "... (list) any arguments to pass to handlers."
.RE
.RS 4
.PD
.Sp
Emit the signal \fIname\fR on \fI$object\fR.  The number and types of additional
arguments in \fI...\fR are determined by the signal; similarly, the presence
and type of return value depends on the signal being emitted.
.RE
.Sh "$object\->\fBsignal_handler_block\fP ($handler_id)"
.IX Subsection "$object->signal_handler_block ($handler_id)"
.RS 4
.ie n .IP "* $handler_id (unsigned)" 4
.el .IP "* \f(CW$handler_id\fR (unsigned)" 4
.IX Item "$handler_id (unsigned)"
.RE
.RS 4
.RE
.Sh "$object\->\fBsignal_handler_disconnect\fP ($handler_id)"
.IX Subsection "$object->signal_handler_disconnect ($handler_id)"
.RS 4
.PD 0
.ie n .IP "* $handler_id (unsigned)" 4
.el .IP "* \f(CW$handler_id\fR (unsigned)" 4
.IX Item "$handler_id (unsigned)"
.RE
.RS 4
.RE
.PD
.ie n .Sh "boolean = $object\fP\->\fBsignal_handler_is_connected ($handler_id)"
.el .Sh "boolean = \f(CW$object\fP\->\fBsignal_handler_is_connected\fP ($handler_id)"
.IX Subsection "boolean = $object->signal_handler_is_connected ($handler_id)"
.RS 4
.ie n .IP "* $handler_id (unsigned)" 4
.el .IP "* \f(CW$handler_id\fR (unsigned)" 4
.IX Item "$handler_id (unsigned)"
.RE
.RS 4
.RE
.Sh "$object\->\fBsignal_handler_unblock\fP ($handler_id)"
.IX Subsection "$object->signal_handler_unblock ($handler_id)"
.RS 4
.PD 0
.ie n .IP "* $handler_id (unsigned)" 4
.el .IP "* \f(CW$handler_id\fR (unsigned)" 4
.IX Item "$handler_id (unsigned)"
.RE
.RS 4
.RE
.PD
.ie n .Sh "integer = $instance\fP\->\fBsignal_handlers_block_by_func\fP ($func, \f(CW$data=undef)"
.el .Sh "integer = \f(CW$instance\fP\->\fBsignal_handlers_block_by_func\fP ($func, \f(CW$data\fP=undef)"
.IX Subsection "integer = $instance->signal_handlers_block_by_func ($func, $data=undef)"
.RS 4
.ie n .IP "* $func (subroutine) function to block" 4
.el .IP "* \f(CW$func\fR (subroutine) function to block" 4
.IX Item "$func (subroutine) function to block"
.PD 0
.ie n .IP "* $data (scalar) data to match, ignored if undef" 4
.el .IP "* \f(CW$data\fR (scalar) data to match, ignored if undef" 4
.IX Item "$data (scalar) data to match, ignored if undef"
.RE
.RS 4
.RE
.PD
.ie n .Sh "integer = $instance\fP\->\fBsignal_handlers_disconnect_by_func\fP ($func, \f(CW$data=undef)"
.el .Sh "integer = \f(CW$instance\fP\->\fBsignal_handlers_disconnect_by_func\fP ($func, \f(CW$data\fP=undef)"
.IX Subsection "integer = $instance->signal_handlers_disconnect_by_func ($func, $data=undef)"
.RS 4
.ie n .IP "* $func (subroutine) function to block" 4
.el .IP "* \f(CW$func\fR (subroutine) function to block" 4
.IX Item "$func (subroutine) function to block"
.PD 0
.ie n .IP "* $data (scalar) data to match, ignored if undef" 4
.el .IP "* \f(CW$data\fR (scalar) data to match, ignored if undef" 4
.IX Item "$data (scalar) data to match, ignored if undef"
.RE
.RS 4
.RE
.PD
.ie n .Sh "integer = $instance\fP\->\fBsignal_handlers_unblock_by_func\fP ($func, \f(CW$data=undef)"
.el .Sh "integer = \f(CW$instance\fP\->\fBsignal_handlers_unblock_by_func\fP ($func, \f(CW$data\fP=undef)"
.IX Subsection "integer = $instance->signal_handlers_unblock_by_func ($func, $data=undef)"
.RS 4
.ie n .IP "* $func (subroutine) function to block" 4
.el .IP "* \f(CW$func\fR (subroutine) function to block" 4
.IX Item "$func (subroutine) function to block"
.PD 0
.ie n .IP "* $data (scalar) data to match, ignored if undef" 4
.el .IP "* \f(CW$data\fR (scalar) data to match, ignored if undef" 4
.IX Item "$data (scalar) data to match, ignored if undef"
.RE
.RS 4
.RE
.PD
.ie n .Sh "scalar = $object_or_class_name\fP\->\fBsignal_query ($name)"
.el .Sh "scalar = \f(CW$object_or_class_name\fP\->\fBsignal_query\fP ($name)"
.IX Subsection "scalar = $object_or_class_name->signal_query ($name)"
.RS 4
.ie n .IP "* $name (string)" 4
.el .IP "* \f(CW$name\fR (string)" 4
.IX Item "$name (string)"
.RE
.RS 4
.Sp
Look up information about the signal \fI$name\fR on the instance type
\&\fI$object_or_class_name\fR, which may be either a Glib::Object or a package
name.
.Sp
See also \f(CW\*(C`Glib::Type::list_signals\*(C'\fR, which returns the same kind of
hash refs as this does.
.Sp
Since 1.080.
.RE
.ie n .Sh "$object_or_class_name\->\fBsignal_remove_emission_hook\fP ($signal_name, $hook_id)"
.el .Sh "$object_or_class_name\->\fBsignal_remove_emission_hook\fP ($signal_name, \f(CW$hook_id\fP)"
.IX Subsection "$object_or_class_name->signal_remove_emission_hook ($signal_name, $hook_id)"
.RS 4
.ie n .IP "* $signal_name (string)" 4
.el .IP "* \f(CW$signal_name\fR (string)" 4
.IX Item "$signal_name (string)"
.PD 0
.ie n .IP "* $hook_id (unsigned)" 4
.el .IP "* \f(CW$hook_id\fR (unsigned)" 4
.IX Item "$hook_id (unsigned)"
.RE
.RS 4
.PD
.Sp
Remove a hook that was installed by \f(CW\*(C`add_emission_hook\*(C'\fR.
.Sp
Since 1.100.
.RE
.Sh "$instance\->\fBsignal_stop_emission_by_name\fP ($detailed_signal)"
.IX Subsection "$instance->signal_stop_emission_by_name ($detailed_signal)"
.RS 4
.ie n .IP "* $detailed_signal (string)" 4
.el .IP "* \f(CW$detailed_signal\fR (string)" 4
.IX Item "$detailed_signal (string)"
.RE
.RS 4
.RE
.Sh "$object\->\fBthaw_notify\fP"
.IX Subsection "$object->thaw_notify"
.RS 4
Reverts the effect of a previous call to \f(CW\*(C`freeze_notify\*(C'\fR. This causes all
queued \*(L"notify\*(R" signals on \fI$object\fR to be emitted.
.RE
.Sh "boolean = Glib::Object\->\fBset_threadsafe\fP ($threadsafe)"
.IX Subsection "boolean = Glib::Object->set_threadsafe ($threadsafe)"
.RS 4
.ie n .IP "* $threadsafe (boolean)" 4
.el .IP "* \f(CW$threadsafe\fR (boolean)" 4
.IX Item "$threadsafe (boolean)"
.RE
.RS 4
.Sp
Enables/disables threadsafe gobject tracking. Returns whether or not tracking
will be successful and thus whether using perl ithreads will be possible. 
.RE
.Sh "$object\->\fBtie_properties\fP ($all=FALSE)"
.IX Subsection "$object->tie_properties ($all=FALSE)"
.RS 4
.ie n .IP "* $all (boolean) if \s-1FALSE\s0 (or omitted) tie only properties for this object's class, if \s-1TRUE\s0 tie the properties of this and all parent classes." 4
.el .IP "* \f(CW$all\fR (boolean) if \s-1FALSE\s0 (or omitted) tie only properties for this object's class, if \s-1TRUE\s0 tie the properties of this and all parent classes." 4
.IX Item "$all (boolean) if FALSE (or omitted) tie only properties for this object's class, if TRUE tie the properties of this and all parent classes."
.RE
.RS 4
.Sp
A special method avaiable to Glib::Object derivatives, it uses perl's tie
facilities to associate hash keys with the properties of the object. For
example:
.Sp
.Vb 4
\&  $button\->tie_properties;
\&  # equivilent to $button\->set (label => 'Hello World');
\&  $button\->{label} = 'Hello World';
\&  print "the label is: ".$button\->{label}."\en";
.Ve
.Sp
Attempts to write to read-only properties will croak, reading a write-only
property will return '[write\-only]'.
.Sp
Care must be taken when using tie_properties with objects of types created with
Glib::Object::Subclass as there may be clashes with existing hash keys that
could cause infinite loops. The solution is to use custom property get/set
functions to alter the storage locations of the properties.
.RE
.SH "SIGNALS"
.IX Header "SIGNALS"
.IP "\fBnotify\fR (Glib::Object, Glib::ParamSpec)" 4
.IX Item "notify (Glib::Object, Glib::ParamSpec)"
.SH "ENUMS AND FLAGS"
.IX Header "ENUMS AND FLAGS"
.Sh "flags Glib::SignalFlags"
.IX Subsection "flags Glib::SignalFlags"
.PD 0
.IP "* 'run\-first' / 'G_SIGNAL_RUN_FIRST'" 4
.IX Item "'run-first' / 'G_SIGNAL_RUN_FIRST'"
.IP "* 'run\-last' / 'G_SIGNAL_RUN_LAST'" 4
.IX Item "'run-last' / 'G_SIGNAL_RUN_LAST'"
.IP "* 'run\-cleanup' / 'G_SIGNAL_RUN_CLEANUP'" 4
.IX Item "'run-cleanup' / 'G_SIGNAL_RUN_CLEANUP'"
.IP "* 'no\-recurse' / 'G_SIGNAL_NO_RECURSE'" 4
.IX Item "'no-recurse' / 'G_SIGNAL_NO_RECURSE'"
.IP "* 'detailed' / 'G_SIGNAL_DETAILED'" 4
.IX Item "'detailed' / 'G_SIGNAL_DETAILED'"
.IP "* 'action' / 'G_SIGNAL_ACTION'" 4
.IX Item "'action' / 'G_SIGNAL_ACTION'"
.IP "* 'no\-hooks' / 'G_SIGNAL_NO_HOOKS'" 4
.IX Item "'no-hooks' / 'G_SIGNAL_NO_HOOKS'"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Glib
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2003\-2006 by the gtk2\-perl team.
.PP
This software is licensed under the \s-1LGPL\s0.  See Glib for a full notice.
