.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Gnome2::Canvas 3pm"
.TH Gnome2::Canvas 3pm "2007-02-26" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Gnome2::Canvas \-  A structured graphics canvas
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 11
\&  use strict;
\&  use Gtk2 \-init;
\&  use Gnome2::Canvas;
\&  my $window = Gtk2::Window\->new;
\&  my $scroller = Gtk2::ScrolledWindow\->new;
\&  my $canvas = Gnome2::Canvas\->new;
\&  $scroller\->add ($canvas);
\&  $window\->add ($scroller);
\&  $window\->set_default_size (150, 150);
\&  $canvas\->set_scroll_region (0, 0, 200, 200);
\&  $window\->show_all;
.Ve
.PP
.Vb 18
\&  my $root = $canvas\->root;
\&  Gnome2::Canvas::Item\->new ($root, 'Gnome2::Canvas::Text',
\&                             x => 20,
\&                             y => 15,
\&                             fill_color => 'black',
\&                             font => 'Sans 14',
\&                             anchor => 'GTK_ANCHOR_NW',
\&                             text => 'Hello, World!');
\&  my $box = Gnome2::Canvas::Item\->new ($root, 'Gnome2::Canvas::Rect',
\&                                       x1 => 10, y1 => 5,
\&                                       x2 => 150, y2 => 135,
\&                                       fill_color => 'red',
\&                                       outline_color => 'black');
\&  $box\->lower_to_bottom;
\&  $box\->signal_connect (event => sub {
\&          my ($item, $event) = @_;
\&          warn "event ".$event\->type."\en";
\&  });
.Ve
.PP
.Vb 1
\&  Gtk2\->main;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Gnome Canvas is an engine for structured graphics that offers a
rich imaging model, high-performance rendering, and a powerful,
high level \s-1API\s0.  It offers a choice of two rendering back\-ends,
one based on \s-1GDK\s0 for extremely fast display, and another based on
Libart, a sophisticated, antialiased, alpha-compositing engine.
This widget can be used for flexible display of graphics and for
creating interactive user interface elements.
.PP
To create a new Gnome2::Canvas widget call \f(CW\*(C`Gnome2::Canvas\->new\*(C'\fR or
\&\f(CW\*(C`Gnome2::Canvas\->new_aa\*(C'\fR for an anti-aliased mode canvas.
.PP
A Gnome2::Canvas contains one or more Gnome2::CanvasItem
objects. Items consist of graphing elements like lines, ellipses,
polygons, images, text, and curves.  These items are organized using
Gnome2::CanvasGroup objects, which are themselves derived from
Gnome2::CanvasItem.  Since a group is an item it can be contained within
other groups, forming a tree of canvas items.  Certain operations, like
translating and scaling, can be performed on all items in a group.
.PP
There is a special root group created by a Gnome2::Canvas.  This is the top
level group under which all items in a canvas are contained.  The root group
is available as \f(CW\*(C`$canvas\->root\*(C'\fR.
.PP
There are several different coordinate systems used by Gnome2::Canvas
widgets.  The primary system is a logical, abstract coordinate space
called world coordinates.  World coordinates are expressed as unbounded
double floating point numbers.  When it comes to rendering to a screen
the canvas pixel coordinate system (also referred to as just canvas
coordinates) is used.  This system uses integers to specify screen
pixel positions.  A user defined scaling factor and offset are used to
convert between world coordinates and canvas coordinates.  Each item in
a canvas has its own coordinate system called item coordinates.  This
system is specified in world coordinates but they are relative to an
item (0.0, 0.0 would be the top left corner of the item).  The final
coordinate system of interest is window coordinates.  These are like
canvas coordinates but are offsets from within a window a canvas is
displayed in.  This last system is rarely used, but is useful when
manually handling \s-1GDK\s0 events (such as drag and drop) which are 
specified in window coordinates (the events processed by the canvas
are already converted for you).
.PP
Along with different coordinate systems come methods to convert
between them.  \f(CW\*(C`$canvas\->w2c\*(C'\fR converts world to canvas pixel
coordinates and \f(CW\*(C`canvas\->c2w\*(C'\fR converts from canvas to
world.  To get the affine transform matrix for converting
from world coordinates to canvas coordinates call \f(CW\*(C`$canvas\->w2c_affine\*(C'\fR.
\&\f(CW\*(C`$canvas\->window_to_world\*(C'\fR converts from window to world
coordinates and \f(CW\*(C`$canvas\->world_to_window\*(C'\fR converts in the other
direction.  There are no methods for converting between canvas and
window coordinates, since this is just a matter of subtracting the
canvas scrolling offset.  To convert to/from item coordinates use the
methods defined for Gnome2::CanvasItem objects.
.PP
To set the canvas zoom factor (canvas pixels per world unit, the
scaling factor) call \f(CW\*(C`$canvas\->set_pixels_per_unit\*(C'\fR; setting this
to 1.0 will cause the two coordinate systems to correspond (e.g., [5, 6]
in pixel units would be [5.0, 6.0] in world units).
.PP
Defining the scrollable area of a canvas widget is done by calling
\&\f(CW\*(C`$canvas\->set_scroll_region\*(C'\fR and to get the current region
\&\f(CW\*(C`$canvas\->get_scroll_region\*(C'\fR can be used.  If the window is
larger than the canvas scrolling region it can optionally be centered
in the window.  Use \f(CW\*(C`$canvas\->set_center_scroll_region\*(C'\fR to enable or
disable this behavior.  To scroll to a particular canvas pixel coordinate
use \f(CW\*(C`$canvas\->scroll_to\*(C'\fR (typically not used since scrollbars are
usually set up to handle the scrolling), and to get the current canvas pixel
scroll offset call \f(CW\*(C`$canvas\->get_scroll_offsets\*(C'\fR.
.SH "HIERARCHY"
.IX Header "HIERARCHY"
.Vb 7
\&  Glib::Object
\&  +\-\-\-\-Glib::InitiallyUnowned
\&       +\-\-\-\-Gtk2::Object
\&            +\-\-\-\-Gtk2::Widget
\&                 +\-\-\-\-Gtk2::Container
\&                      +\-\-\-\-Gtk2::Layout
\&                           +\-\-\-\-Gnome2::Canvas
.Ve
.SH "INTERFACES"
.IX Header "INTERFACES"
.Vb 1
\&  Glib::Object::_Unregistered::AtkImplementorIface
.Ve
.SH "METHODS"
.IX Header "METHODS"
.Sh "widget = Gnome2::Canvas\->\fBnew\fP"
.IX Subsection "widget = Gnome2::Canvas->new"
.RS 4
Create a new empty canvas in non-antialiased mode.
.RE
.Sh "widget = Gnome2::Canvas\->\fBnew_aa\fP"
.IX Subsection "widget = Gnome2::Canvas->new_aa"
.RS 4
Create a new empty canvas in antialiased mode.
.RE
.ie n .Sh "boolean = $canvas\fP\->\fBaa"
.el .Sh "boolean = \f(CW$canvas\fP\->\fBaa\fP"
.IX Subsection "boolean = $canvas->aa"
.RS 4
Returns true if \fI$canvas\fR was created in anti-aliased mode.
.RE
.ie n .Sh "($bx1, $by1\fP, \f(CW$bx2\fP, \f(CW$by2\fP) = Gnome2::Canvas\->\fBget_butt_points\fP ($x1, \f(CW$y1\fP, \f(CW$x2\fP, \f(CW$y2\fP, \f(CW$width\fP, \f(CW$project)"
.el .Sh "($bx1, \f(CW$by1\fP, \f(CW$bx2\fP, \f(CW$by2\fP) = Gnome2::Canvas\->\fBget_butt_points\fP ($x1, \f(CW$y1\fP, \f(CW$x2\fP, \f(CW$y2\fP, \f(CW$width\fP, \f(CW$project\fP)"
.IX Subsection "($bx1, $by1, $bx2, $by2) = Gnome2::Canvas->get_butt_points ($x1, $y1, $x2, $y2, $width, $project)"
.RS 4
.ie n .IP "* $x1 (double)" 4
.el .IP "* \f(CW$x1\fR (double)" 4
.IX Item "$x1 (double)"
.PD 0
.ie n .IP "* $y1 (double)" 4
.el .IP "* \f(CW$y1\fR (double)" 4
.IX Item "$y1 (double)"
.ie n .IP "* $x2 (double)" 4
.el .IP "* \f(CW$x2\fR (double)" 4
.IX Item "$x2 (double)"
.ie n .IP "* $y2 (double)" 4
.el .IP "* \f(CW$y2\fR (double)" 4
.IX Item "$y2 (double)"
.ie n .IP "* $width (double)" 4
.el .IP "* \f(CW$width\fR (double)" 4
.IX Item "$width (double)"
.ie n .IP "* $project (integer)" 4
.el .IP "* \f(CW$project\fR (integer)" 4
.IX Item "$project (integer)"
.RE
.RS 4
.RE
.PD
.ie n .Sh "(wx, wy) = $canvas\fP\->\fBc2w\fP ($cx, \f(CW$cy)"
.el .Sh "(wx, wy) = \f(CW$canvas\fP\->\fBc2w\fP ($cx, \f(CW$cy\fP)"
.IX Subsection "(wx, wy) = $canvas->c2w ($cx, $cy)"
.RS 4
.ie n .IP "* $cx (integer)" 4
.el .IP "* \f(CW$cx\fR (integer)" 4
.IX Item "$cx (integer)"
.PD 0
.ie n .IP "* $cy (integer)" 4
.el .IP "* \f(CW$cy\fR (integer)" 4
.IX Item "$cy (integer)"
.RE
.RS 4
.RE
.PD
.ie n .Sh "boolean = $canvas\fP\->\fBget_center_scroll_region"
.el .Sh "boolean = \f(CW$canvas\fP\->\fBget_center_scroll_region\fP"
.IX Subsection "boolean = $canvas->get_center_scroll_region"
.Sh "$canvas\->\fBset_center_scroll_region\fP ($center_scroll_region)"
.IX Subsection "$canvas->set_center_scroll_region ($center_scroll_region)"
.RS 4
.ie n .IP "* $center_scroll_region (boolean)" 4
.el .IP "* \f(CW$center_scroll_region\fR (boolean)" 4
.IX Item "$center_scroll_region (boolean)"
.RE
.RS 4
.RE
.ie n .Sh "list = $canvas\fP\->\fBget_color ($spec)"
.el .Sh "list = \f(CW$canvas\fP\->\fBget_color\fP ($spec)"
.IX Subsection "list = $canvas->get_color ($spec)"
.RS 4
.PD 0
.ie n .IP "* $spec (string)" 4
.el .IP "* \f(CW$spec\fR (string)" 4
.IX Item "$spec (string)"
.RE
.RS 4
.PD
.Sp
Returns an integer indicating the success of the color allocation and a
GdkColor.
.RE
.ie n .Sh "unsigned = $canvas\fP\->\fBget_color_pixel ($rgba)"
.el .Sh "unsigned = \f(CW$canvas\fP\->\fBget_color_pixel\fP ($rgba)"
.IX Subsection "unsigned = $canvas->get_color_pixel ($rgba)"
.RS 4
.ie n .IP "* $rgba (integer)" 4
.el .IP "* \f(CW$rgba\fR (integer)" 4
.IX Item "$rgba (integer)"
.RE
.RS 4
.RE
.ie n .Sh "rgbdither = $canvas\fP\->\fBget_dither"
.el .Sh "rgbdither = \f(CW$canvas\fP\->\fBget_dither\fP"
.IX Subsection "rgbdither = $canvas->get_dither"
.Sh "$canvas\->\fBset_dither\fP ($dither)"
.IX Subsection "$canvas->set_dither ($dither)"
.RS 4
.PD 0
.ie n .IP "* $dither (Gtk2::Gdk::RgbDither)" 4
.el .IP "* \f(CW$dither\fR (Gtk2::Gdk::RgbDither)" 4
.IX Item "$dither (Gtk2::Gdk::RgbDither)"
.RE
.RS 4
.RE
.PD
.ie n .Sh "item = $canvas\fP\->\fBget_item_at\fP ($x, \f(CW$y)"
.el .Sh "item = \f(CW$canvas\fP\->\fBget_item_at\fP ($x, \f(CW$y\fP)"
.IX Subsection "item = $canvas->get_item_at ($x, $y)"
.RS 4
.ie n .IP "* $x (double)" 4
.el .IP "* \f(CW$x\fR (double)" 4
.IX Item "$x (double)"
.PD 0
.ie n .IP "* $y (double)" 4
.el .IP "* \f(CW$y\fR (double)" 4
.IX Item "$y (double)"
.RE
.RS 4
.RE
.PD
.ie n .Sh "($mx1, $my1\fP, \f(CW$mx2\fP, \f(CW$my2\fP) = Gnome2::Canvas\->\fBget_miter_points\fP ($x1, \f(CW$y1\fP, \f(CW$x2\fP, \f(CW$y2\fP, \f(CW$x3\fP, \f(CW$y3\fP, \f(CW$width)"
.el .Sh "($mx1, \f(CW$my1\fP, \f(CW$mx2\fP, \f(CW$my2\fP) = Gnome2::Canvas\->\fBget_miter_points\fP ($x1, \f(CW$y1\fP, \f(CW$x2\fP, \f(CW$y2\fP, \f(CW$x3\fP, \f(CW$y3\fP, \f(CW$width\fP)"
.IX Subsection "($mx1, $my1, $mx2, $my2) = Gnome2::Canvas->get_miter_points ($x1, $y1, $x2, $y2, $x3, $y3, $width)"
.RS 4
.ie n .IP "* $x1 (double)" 4
.el .IP "* \f(CW$x1\fR (double)" 4
.IX Item "$x1 (double)"
.PD 0
.ie n .IP "* $y1 (double)" 4
.el .IP "* \f(CW$y1\fR (double)" 4
.IX Item "$y1 (double)"
.ie n .IP "* $x2 (double)" 4
.el .IP "* \f(CW$x2\fR (double)" 4
.IX Item "$x2 (double)"
.ie n .IP "* $y2 (double)" 4
.el .IP "* \f(CW$y2\fR (double)" 4
.IX Item "$y2 (double)"
.ie n .IP "* $x3 (double)" 4
.el .IP "* \f(CW$x3\fR (double)" 4
.IX Item "$x3 (double)"
.ie n .IP "* $y3 (double)" 4
.el .IP "* \f(CW$y3\fR (double)" 4
.IX Item "$y3 (double)"
.ie n .IP "* $width (double)" 4
.el .IP "* \f(CW$width\fR (double)" 4
.IX Item "$width (double)"
.RE
.RS 4
.RE
.PD
.ie n .Sh "double = $canvas\fP\->\fBget_pixels_per_unit"
.el .Sh "double = \f(CW$canvas\fP\->\fBget_pixels_per_unit\fP"
.IX Subsection "double = $canvas->get_pixels_per_unit"
.RS 4
Fetch \fI$canvas\fR' scale factor.
.RE
.Sh "$canvas\->\fBset_pixels_per_unit\fP ($n)"
.IX Subsection "$canvas->set_pixels_per_unit ($n)"
.RS 4
.ie n .IP "* $n (double)" 4
.el .IP "* \f(CW$n\fR (double)" 4
.IX Item "$n (double)"
.RE
.RS 4
.Sp
Set the zooming factor of \fI$canvas\fR by specifying the number of screen
pixels that correspond to one canvas unit.
.RE
.ie n .Sh "double = Gnome2::Canvas\->\fBpolygon_to_point\fP ($poly_ref, $x\fP, \f(CW$y)"
.el .Sh "double = Gnome2::Canvas\->\fBpolygon_to_point\fP ($poly_ref, \f(CW$x\fP, \f(CW$y\fP)"
.IX Subsection "double = Gnome2::Canvas->polygon_to_point ($poly_ref, $x, $y)"
.RS 4
.ie n .IP "* $poly_ref (arrayref) coordinate pairs that make up the polygon" 4
.el .IP "* \f(CW$poly_ref\fR (arrayref) coordinate pairs that make up the polygon" 4
.IX Item "$poly_ref (arrayref) coordinate pairs that make up the polygon"
.PD 0
.ie n .IP "* $x (double)" 4
.el .IP "* \f(CW$x\fR (double)" 4
.IX Item "$x (double)"
.ie n .IP "* $y (double)" 4
.el .IP "* \f(CW$y\fR (double)" 4
.IX Item "$y (double)"
.RE
.RS 4
.PD
.Sp
Return the distance from the point \fI$x\fR,\fI$y\fR to the polygon described by
the vertices in \fI$poly_ref\fR, or zero if the point is inside the polygon.
.RE
.ie n .Sh "$canvas\->\fBrequest_redraw\fP ($x1, $y1\fP, \f(CW$x2\fP, \f(CW$y2)"
.el .Sh "$canvas\->\fBrequest_redraw\fP ($x1, \f(CW$y1\fP, \f(CW$x2\fP, \f(CW$y2\fP)"
.IX Subsection "$canvas->request_redraw ($x1, $y1, $x2, $y2)"
.RS 4
.ie n .IP "* $x1 (integer)" 4
.el .IP "* \f(CW$x1\fR (integer)" 4
.IX Item "$x1 (integer)"
.PD 0
.ie n .IP "* $y1 (integer)" 4
.el .IP "* \f(CW$y1\fR (integer)" 4
.IX Item "$y1 (integer)"
.ie n .IP "* $x2 (integer)" 4
.el .IP "* \f(CW$x2\fR (integer)" 4
.IX Item "$x2 (integer)"
.ie n .IP "* $y2 (integer)" 4
.el .IP "* \f(CW$y2\fR (integer)" 4
.IX Item "$y2 (integer)"
.RE
.RS 4
.RE
.PD
.ie n .Sh "group = $canvas\fP\->\fBroot"
.el .Sh "group = \f(CW$canvas\fP\->\fBroot\fP"
.IX Subsection "group = $canvas->root"
.ie n .Sh "(cx, cy) = $canvas\fP\->\fBget_scroll_offsets"
.el .Sh "(cx, cy) = \f(CW$canvas\fP\->\fBget_scroll_offsets\fP"
.IX Subsection "(cx, cy) = $canvas->get_scroll_offsets"
.ie n .Sh "(x1, y1, x2, y2) = $canvas\fP\->\fBget_scroll_region"
.el .Sh "(x1, y1, x2, y2) = \f(CW$canvas\fP\->\fBget_scroll_region\fP"
.IX Subsection "(x1, y1, x2, y2) = $canvas->get_scroll_region"
.ie n .Sh "$canvas\->\fBset_scroll_region\fP ($x1, $y1\fP, \f(CW$x2\fP, \f(CW$y2)"
.el .Sh "$canvas\->\fBset_scroll_region\fP ($x1, \f(CW$y1\fP, \f(CW$x2\fP, \f(CW$y2\fP)"
.IX Subsection "$canvas->set_scroll_region ($x1, $y1, $x2, $y2)"
.RS 4
.ie n .IP "* $x1 (double)" 4
.el .IP "* \f(CW$x1\fR (double)" 4
.IX Item "$x1 (double)"
.PD 0
.ie n .IP "* $y1 (double)" 4
.el .IP "* \f(CW$y1\fR (double)" 4
.IX Item "$y1 (double)"
.ie n .IP "* $x2 (double)" 4
.el .IP "* \f(CW$x2\fR (double)" 4
.IX Item "$x2 (double)"
.ie n .IP "* $y2 (double)" 4
.el .IP "* \f(CW$y2\fR (double)" 4
.IX Item "$y2 (double)"
.RE
.RS 4
.RE
.PD
.ie n .Sh "$canvas\->\fBscroll_to\fP ($cx, $cy)"
.el .Sh "$canvas\->\fBscroll_to\fP ($cx, \f(CW$cy\fP)"
.IX Subsection "$canvas->scroll_to ($cx, $cy)"
.RS 4
.ie n .IP "* $cx (integer)" 4
.el .IP "* \f(CW$cx\fR (integer)" 4
.IX Item "$cx (integer)"
.PD 0
.ie n .IP "* $cy (integer)" 4
.el .IP "* \f(CW$cy\fR (integer)" 4
.IX Item "$cy (integer)"
.RE
.RS 4
.RE
.PD
.Sh "$canvas\->\fBset_stipple_origin\fP ($gc)"
.IX Subsection "$canvas->set_stipple_origin ($gc)"
.RS 4
.ie n .IP "* $gc (Gtk2::Gdk::GC)" 4
.el .IP "* \f(CW$gc\fR (Gtk2::Gdk::GC)" 4
.IX Item "$gc (Gtk2::Gdk::GC)"
.RE
.RS 4
.RE
.Sh "$canvas\->\fBupdate_now\fP"
.IX Subsection "$canvas->update_now"
.ie n .Sh "(cx, cy) = $canvas\fP\->\fBw2c\fP ($wx, \f(CW$wy)"
.el .Sh "(cx, cy) = \f(CW$canvas\fP\->\fBw2c\fP ($wx, \f(CW$wy\fP)"
.IX Subsection "(cx, cy) = $canvas->w2c ($wx, $wy)"
.RS 4
.PD 0
.ie n .IP "* $wx (double)" 4
.el .IP "* \f(CW$wx\fR (double)" 4
.IX Item "$wx (double)"
.ie n .IP "* $wy (double)" 4
.el .IP "* \f(CW$wy\fR (double)" 4
.IX Item "$wy (double)"
.RE
.RS 4
.RE
.PD
.ie n .Sh "$affine = $canvas\fP\->\fBw2c_affine"
.el .Sh "$affine = \f(CW$canvas\fP\->\fBw2c_affine\fP"
.IX Subsection "$affine = $canvas->w2c_affine"
.RS 4
.RE
.RS 4
.Sp
Fetch the affine transform that converts from world coordinates to canvas
pixel coordinates.
.Sp
Note: This method was completely broken for all
\&\f(CW$Gnome2::Canvas::VERSION\fR < 1.002.
.RE
.ie n .Sh "(cx, cy) = $canvas\fP\->\fBw2c_d\fP ($wx, \f(CW$wy)"
.el .Sh "(cx, cy) = \f(CW$canvas\fP\->\fBw2c_d\fP ($wx, \f(CW$wy\fP)"
.IX Subsection "(cx, cy) = $canvas->w2c_d ($wx, $wy)"
.RS 4
.ie n .IP "* $wx (double)" 4
.el .IP "* \f(CW$wx\fR (double)" 4
.IX Item "$wx (double)"
.PD 0
.ie n .IP "* $wy (double)" 4
.el .IP "* \f(CW$wy\fR (double)" 4
.IX Item "$wy (double)"
.RE
.RS 4
.RE
.PD
.ie n .Sh "(worldx, worldy) = $canvas\fP\->\fBwindow_to_world\fP ($winx, \f(CW$winy)"
.el .Sh "(worldx, worldy) = \f(CW$canvas\fP\->\fBwindow_to_world\fP ($winx, \f(CW$winy\fP)"
.IX Subsection "(worldx, worldy) = $canvas->window_to_world ($winx, $winy)"
.RS 4
.ie n .IP "* $winx (double)" 4
.el .IP "* \f(CW$winx\fR (double)" 4
.IX Item "$winx (double)"
.PD 0
.ie n .IP "* $winy (double)" 4
.el .IP "* \f(CW$winy\fR (double)" 4
.IX Item "$winy (double)"
.RE
.RS 4
.RE
.PD
.ie n .Sh "(winx, winy) = $canvas\fP\->\fBworld_to_window\fP ($worldx, \f(CW$worldy)"
.el .Sh "(winx, winy) = \f(CW$canvas\fP\->\fBworld_to_window\fP ($worldx, \f(CW$worldy\fP)"
.IX Subsection "(winx, winy) = $canvas->world_to_window ($worldx, $worldy)"
.RS 4
.ie n .IP "* $worldx (double)" 4
.el .IP "* \f(CW$worldx\fR (double)" 4
.IX Item "$worldx (double)"
.PD 0
.ie n .IP "* $worldy (double)" 4
.el .IP "* \f(CW$worldy\fR (double)" 4
.IX Item "$worldy (double)"
.RE
.RS 4
.RE
.PD
.SH "PROPERTIES"
.IX Header "PROPERTIES"
.IP "'aa' (boolean : readable / writable / construct\-only)" 4
.IX Item "'aa' (boolean : readable / writable / construct-only)"
The antialiasing mode of the canvas.
.SH "SIGNALS"
.IX Header "SIGNALS"
.IP "\fBdraw-background\fR (Gnome2::Canvas, Gtk2::Gdk::Drawable, integer, integer, integer, integer)" 4
.IX Item "draw-background (Gnome2::Canvas, Gtk2::Gdk::Drawable, integer, integer, integer, integer)"
.PD 0
.IP "\fBrender-background\fR (Gnome2::Canvas, gpointer)" 4
.IX Item "render-background (Gnome2::Canvas, gpointer)"
.PD
.SH "ENUMS AND FLAGS"
.IX Header "ENUMS AND FLAGS"
.Sh "enum Gtk2::Gdk::RgbDither"
.IX Subsection "enum Gtk2::Gdk::RgbDither"
.IP "* 'none' / '\s-1GDK_RGB_DITHER_NONE\s0'" 4
.IX Item "'none' / 'GDK_RGB_DITHER_NONE'"
.PD 0
.IP "* 'normal' / '\s-1GDK_RGB_DITHER_NORMAL\s0'" 4
.IX Item "'normal' / 'GDK_RGB_DITHER_NORMAL'"
.IP "* 'max' / '\s-1GDK_RGB_DITHER_MAX\s0'" 4
.IX Item "'max' / 'GDK_RGB_DITHER_MAX'"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIGnome2::Canvas::index\fR\|(3pm) lists the generated Perl \s-1API\s0 reference PODs.
.PP
Frederico Mena Quintero's whitepaper on the \s-1GNOME\s0 Canvas:
http://developer.gnome.org/doc/whitepapers/canvas/canvas.html
.PP
The real GnomeCanvas is implemented in a C library; the Gnome2::Canvas module
allows a Perl developer to use the canvas like a normal gtk2\-perl object.
Like the Gtk2 module on which it depends, Gnome2::Canvas follows the C \s-1API\s0 of
libgnomecanvas\-2.0 as closely as possible while still being perlish.
Thus, the C \s-1API\s0 reference remains the canonical documentation; the Perl
reference documentation lists call signatures and argument types, and is
meant to be used in conjunction with the C \s-1API\s0 reference.
.PP
\&\s-1GNOME\s0 Canvas Library Reference Manual
http://developer.gnome.org/doc/API/2.0/libgnomecanvas/index.html
.PP
\&\fIperl\fR\|(1), \fIGlib\fR\|(3pm), \fIGtk2\fR\|(3pm).
.PP
To discuss gtk2\-perl, ask questions and flame/praise the authors,
join gtk\-perl\-list@gnome.org at lists.gnome.org.
.SH "AUTHOR"
.IX Header "AUTHOR"
muppet <scott at asofyet dot org>, with patches from
Torsten Schoenfeld <kaffetisch at web dot de>.
.PP
The \s-1DESCRIPTION\s0 section of this page is adapted from the documentation of
libgnomecanvas.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2003\-2004 by the gtk2\-perl team.
.PP
This library is free software; you can redistribute it and/or
modify it under the terms of the \s-1GNU\s0 Library General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.
.PP
This library is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See the \s-1GNU\s0
Library General Public License for more details.
.PP
You should have received a copy of the \s-1GNU\s0 Library General Public
License along with this library; if not, write to the 
Free Software Foundation, Inc., 59 Temple Place \- Suite 330, 
Boston, \s-1MA\s0  02111\-1307  \s-1USA\s0.
