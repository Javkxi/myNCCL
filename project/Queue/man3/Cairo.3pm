.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Cairo 3pm"
.TH Cairo 3pm "2006-09-24" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Cairo \- Perl interface to the cairo library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Cairo;
.Ve
.PP
.Vb 2
\&  my $surface = Cairo::ImageSurface\->create ('argb32', 100, 100);
\&  my $cr = Cairo::Context\->create ($surface);
.Ve
.PP
.Vb 3
\&  $cr\->rectangle (10, 10, 40, 40);
\&  $cr\->set_source_rgb (0, 0, 0);
\&  $cr\->fill;
.Ve
.PP
.Vb 3
\&  $cr\->rectangle (50, 50, 40, 40);
\&  $cr\->set_source_rgb (1, 1, 1);
\&  $cr\->fill;
.Ve
.PP
.Vb 1
\&  $cr\->show_page;
.Ve
.PP
.Vb 1
\&  $surface\->write_to_png ("output.png");
.Ve
.SH "ABSTRACT"
.IX Header "ABSTRACT"
Cairo provides Perl bindings for the vector graphics library cairo.  It
supports multiple output targets, including \s-1PNG\s0, \s-1PDF\s0 and \s-1SVG\s0.  Cairo produces
identical output on all those targets.
.SH "API DOCUMENTATION"
.IX Header "API DOCUMENTATION"
Note that this listing still lacks entries for \fICairo::Surface\fRs and some
utility methods.
.Sh "Drawing"
.IX Subsection "Drawing"
\fICairo::Context \*(-- The cairo drawing context\fR
.IX Subsection "Cairo::Context  The cairo drawing context"
.PP
\&\fICairo::Context\fR is the main object used when drawing with Cairo. To draw with
Cairo, you create a \fICairo::Context\fR, set the target surface, and drawing
options for the \fICairo::Context\fR, create shapes with methods like
\&\f(CW\*(C`$cr\-\*(C'\fRmove_to> and \f(CW\*(C`$cr\->line_to\*(C'\fR, and then draw shapes with
\&\f(CW\*(C`$cr\->stroke\*(C'\fR or \f(CW\*(C`$cr\->fill\*(C'\fR.
.PP
\&\fICairo::Context\fR's can be pushed to a stack via \f(CW\*(C`$cr\->save\*(C'\fR. They may
then safely be changed, without loosing the current state. Use
\&\f(CW\*(C`$cr\->restore\*(C'\fR to restore to the saved state.
=over
.PP
$cr = Cairo::Context\->create ($surface)
.IX Subsection "$cr = Cairo::Context->create ($surface)"
.IP "$surface: \fICairo::Surface\fR" 4
.IX Item "$surface: Cairo::Surface"
.PP
$cr\->save
.IX Subsection "$cr->save"
.PP
$cr\->restore
.IX Subsection "$cr->restore"
.PP
$status = \f(CW$cr\fR\->status
.IX Subsection "$status = $cr->status"
.PP
$surface = \f(CW$cr\fR\->get_target
.IX Subsection "$surface = $cr->get_target"
.PP
$cr\->push_group
.IX Subsection "$cr->push_group"
.PP
$cr\->push_group_with_content ($content)
.IX Subsection "$cr->push_group_with_content ($content)"
.IP "$content: \fICairo::Content\fR" 4
.IX Item "$content: Cairo::Content"
.PP
$pattern = \f(CW$cr\fR\->pop_group
.IX Subsection "$pattern = $cr->pop_group"
.PP
$cr\->pop_group_to_source
.IX Subsection "$cr->pop_group_to_source"
.PP
$surface = \f(CW$cr\fR\->get_group_target
.IX Subsection "$surface = $cr->get_group_target"
.PP
$cr\->set_source_rgb ($red, \f(CW$green\fR, \f(CW$blue\fR)
.IX Subsection "$cr->set_source_rgb ($red, $green, $blue)"
.IP "$red: double" 4
.IX Item "$red: double"
.PD 0
.IP "$green: double" 4
.IX Item "$green: double"
.IP "$blue: double" 4
.IX Item "$blue: double"
.PD
.PP
$cr\->set_source_rgba ($red, \f(CW$green\fR, \f(CW$blue\fR, \f(CW$alpha\fR)
.IX Subsection "$cr->set_source_rgba ($red, $green, $blue, $alpha)"
.IP "$red: double" 4
.IX Item "$red: double"
.PD 0
.IP "$green: double" 4
.IX Item "$green: double"
.IP "$blue: double" 4
.IX Item "$blue: double"
.IP "$alpha: double" 4
.IX Item "$alpha: double"
.PD
.PP
$cr\->set_source ($source)
.IX Subsection "$cr->set_source ($source)"
.IP "$source: \fICairo::Pattern\fR" 4
.IX Item "$source: Cairo::Pattern"
.PP
$cr\->set_source_surface ($surface, \f(CW$x\fR, \f(CW$y\fR)
.IX Subsection "$cr->set_source_surface ($surface, $x, $y)"
.IP "$surface: \fICairo::Surface\fR" 4
.IX Item "$surface: Cairo::Surface"
.PD 0
.IP "$x: double" 4
.IX Item "$x: double"
.IP "$y: double" 4
.IX Item "$y: double"
.PD
.PP
$source = \f(CW$cr\fR\->get_source
.IX Subsection "$source = $cr->get_source"
.PP
$cr\->set_antialias ($antialias)
.IX Subsection "$cr->set_antialias ($antialias)"
.IP "$antialias: \fICairo::Antialias\fR" 4
.IX Item "$antialias: Cairo::Antialias"
.PP
$antialias = \f(CW$cr\fR\->get_antialias
.IX Subsection "$antialias = $cr->get_antialias"
.PP
$cr\->set_dash ($offset, ...)
.IX Subsection "$cr->set_dash ($offset, ...)"
.IP "$offset: double" 4
.IX Item "$offset: double"
.PD 0
.IP "...: list of doubles" 4
.IX Item "...: list of doubles"
.PD
.PP
$cr\->set_fill_rule ($fill_rule)
.IX Subsection "$cr->set_fill_rule ($fill_rule)"
.IP "$fill_rule: \fICairo::FillRule\fR" 4
.IX Item "$fill_rule: Cairo::FillRule"
.PP
$fill_rule = \f(CW$cr\fR\->get_fill_rule
.IX Subsection "$fill_rule = $cr->get_fill_rule"
.PP
$cr\->set_line_cap ($line_cap)
.IX Subsection "$cr->set_line_cap ($line_cap)"
.IP "$line_cap: \fICairo::LineCap\fR" 4
.IX Item "$line_cap: Cairo::LineCap"
.PP
$line_cap = \f(CW$cr\fR\->get_line_cap
.IX Subsection "$line_cap = $cr->get_line_cap"
.PP
$cr\->set_line_join ($line_join)
.IX Subsection "$cr->set_line_join ($line_join)"
.IP "$line_join: \fICairo::LineJoin\fR" 4
.IX Item "$line_join: Cairo::LineJoin"
.PP
$line_join = \f(CW$cr\fR\->get_line_join
.IX Subsection "$line_join = $cr->get_line_join"
.PP
$cr\->set_line_width ($width)
.IX Subsection "$cr->set_line_width ($width)"
.IP "$width: double" 4
.IX Item "$width: double"
.PP
$width = \f(CW$cr\fR\->get_line_width
.IX Subsection "$width = $cr->get_line_width"
.PP
$cr\->set_miter_limit ($ limit)
.IX Subsection "$cr->set_miter_limit ($ limit)"
.IP "$limit: double" 4
.IX Item "$limit: double"
.PP
$limit = \f(CW$cr\fR\->get_miter_limit
.IX Subsection "$limit = $cr->get_miter_limit"
.PP
$cr\->set_operator ($op)
.IX Subsection "$cr->set_operator ($op)"
.IP "$op: \fICairo::Operator\fR" 4
.IX Item "$op: Cairo::Operator"
.PP
$op = \f(CW$cr\fR\->get_operator
.IX Subsection "$op = $cr->get_operator"
.PP
$cr\->set_tolerance ($tolerance)
.IX Subsection "$cr->set_tolerance ($tolerance)"
.IP "$tolerance: double" 4
.IX Item "$tolerance: double"
.PP
$tolerance = \f(CW$cr\fR\->get_tolerance
.IX Subsection "$tolerance = $cr->get_tolerance"
.PP
$cr\->clip
.IX Subsection "$cr->clip"
.PP
$cr\->clip_preserve
.IX Subsection "$cr->clip_preserve"
.PP
$cr\->reset_clip
.IX Subsection "$cr->reset_clip"
.PP
$cr\->fill
.IX Subsection "$cr->fill"
.PP
$cr\->fill_preserve
.IX Subsection "$cr->fill_preserve"
.PP
($x1, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR) = \f(CW$cr\fR\->fill_extents
.IX Subsection "($x1, $y1, $x2, $y2) = $cr->fill_extents"
.PP
$bool = \f(CW$cr\fR\->in_fill ($x, \f(CW$y\fR)
.IX Subsection "$bool = $cr->in_fill ($x, $y)"
.IP "$x: double" 4
.IX Item "$x: double"
.PD 0
.IP "$y: double" 4
.IX Item "$y: double"
.PD
.PP
$cr\->mask ($pattern)
.IX Subsection "$cr->mask ($pattern)"
.IP "$pattern: \fICairo::Pattern\fR" 4
.IX Item "$pattern: Cairo::Pattern"
.PP
$cr\->mask_surface ($surface, \f(CW$surface_x\fR, \f(CW$surface_y\fR)
.IX Subsection "$cr->mask_surface ($surface, $surface_x, $surface_y)"
.IP "$surface: \fICairo::Surface\fR" 4
.IX Item "$surface: Cairo::Surface"
.PD 0
.IP "$surface_x: double" 4
.IX Item "$surface_x: double"
.IP "$surface_y: double" 4
.IX Item "$surface_y: double"
.PD
.PP
$cr\->paint
.IX Subsection "$cr->paint"
.PP
$cr\->paint_with_alpha ($alpha)
.IX Subsection "$cr->paint_with_alpha ($alpha)"
.IP "$alpha: double" 4
.IX Item "$alpha: double"
.PP
$cr\->stroke
.IX Subsection "$cr->stroke"
.PP
$cr\->stroke_preserve
.IX Subsection "$cr->stroke_preserve"
.PP
($x1, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR) = \f(CW$cr\fR\->stroke_extents
.IX Subsection "($x1, $y1, $x2, $y2) = $cr->stroke_extents"
.PP
$bool = \f(CW$cr\fR\->in_stroke ($x, \f(CW$y\fR)
.IX Subsection "$bool = $cr->in_stroke ($x, $y)"
.IP "$x: double" 4
.IX Item "$x: double"
.PD 0
.IP "$y: double" 4
.IX Item "$y: double"
.PD
.PP
$cr\->copy_page
.IX Subsection "$cr->copy_page"
.PP
$cr\->show_page
.IX Subsection "$cr->show_page"
.PP
\fIPaths \*(-- Creating paths and manipulating path data\fR
.IX Subsection "Paths  Creating paths and manipulating path data"
.PP
.Vb 7
\&  $path = [
\&    { type => "move\-to", points => [[1, 2]] },
\&    { type => "line\-to", points => [[3, 4]] },
\&    { type => "curve\-to", points => [[5, 6], [7, 8], [9, 10]] },
\&    ...
\&    { type => "close\-path", points => [] },
\&  ];
.Ve
.PP
\&\fICairo::Path\fR is a data structure for holding a path. This data structure
serves as the return value for \f(CW\*(C`$cr\->copy_path_data\*(C'\fR and
\&\f(CW\*(C`$cr\->copy_path_data_flat\*(C'\fR as well the input value for
\&\f(CW\*(C`$cr\->append_path\*(C'\fR.
.PP
\&\fICairo::Path\fR is represented as an array reference that contains path
elements, represented by hash references with two keys: \fItype\fR and \fIpoints\fR.
The value for \fItype\fR can be either of the following:
.ie n .IP """move\-to""" 4
.el .IP "\f(CWmove\-to\fR" 4
.IX Item "move-to"
.PD 0
.ie n .IP """line\-to""" 4
.el .IP "\f(CWline\-to\fR" 4
.IX Item "line-to"
.ie n .IP """curve\-to""" 4
.el .IP "\f(CWcurve\-to\fR" 4
.IX Item "curve-to"
.ie n .IP """close\-path""" 4
.el .IP "\f(CWclose\-path\fR" 4
.IX Item "close-path"
.PD
.PP
The value for \fIpoints\fR is an array reference which contains zero or more
points.  Points are represented as array references that contain two doubles:
\&\fIx\fR and \fIy\fR.  The necessary number of points depends on the \fItype\fR of the
path element:
.ie n .IP """move\-to"": 1 point" 4
.el .IP "\f(CWmove\-to\fR: 1 point" 4
.IX Item "move-to: 1 point"
.PD 0
.ie n .IP """line_to"": 1 point" 4
.el .IP "\f(CWline_to\fR: 1 point" 4
.IX Item "line_to: 1 point"
.ie n .IP """curve\-to"": 3 points" 4
.el .IP "\f(CWcurve\-to\fR: 3 points" 4
.IX Item "curve-to: 3 points"
.ie n .IP """close\-path"": 0 points" 4
.el .IP "\f(CWclose\-path\fR: 0 points" 4
.IX Item "close-path: 0 points"
.PD
.PP
The semantics and ordering of the coordinate values are consistent with
\&\f(CW\*(C`$cr\->move_to\*(C'\fR, \f(CW\*(C`$cr\->line_to\*(C'\fR, \f(CW\*(C`$cr\->curve_to\*(C'\fR, and
\&\f(CW\*(C`$cr\->close_path\*(C'\fR.
.PP
$path = \f(CW$cr\fR\->copy_path
.IX Subsection "$path = $cr->copy_path"
.PP
$path = \f(CW$cr\fR\->copy_path_flat
.IX Subsection "$path = $cr->copy_path_flat"
.PP
$cr\->append_path ($path)
.IX Subsection "$cr->append_path ($path)"
.IP "$path: \fICairo::Path\fR" 4
.IX Item "$path: Cairo::Path"
.PP
($x, \f(CW$y\fR) = \f(CW$cr\fR\->get_current_point
.IX Subsection "($x, $y) = $cr->get_current_point"
.PP
$cr\->new_path
.IX Subsection "$cr->new_path"
.PP
$cr\->new_sub_path
.IX Subsection "$cr->new_sub_path"
.PP
$cr\->close_path
.IX Subsection "$cr->close_path"
.PP
$cr\->arc ($xc, \f(CW$yc\fR, \f(CW$radius\fR, \f(CW$angle1\fR, \f(CW$angle2\fR)
.IX Subsection "$cr->arc ($xc, $yc, $radius, $angle1, $angle2)"
.IP "$xc: double" 4
.IX Item "$xc: double"
.PD 0
.IP "$yc: double" 4
.IX Item "$yc: double"
.IP "$radius: double" 4
.IX Item "$radius: double"
.IP "$angle1: double" 4
.IX Item "$angle1: double"
.IP "$angle2: double" 4
.IX Item "$angle2: double"
.PD
.PP
$cr\->arc_negative ($xc, \f(CW$yc\fR, \f(CW$radius\fR, \f(CW$angle1\fR, \f(CW$angle2\fR)
.IX Subsection "$cr->arc_negative ($xc, $yc, $radius, $angle1, $angle2)"
.IP "$xc: double" 4
.IX Item "$xc: double"
.PD 0
.IP "$yc: double" 4
.IX Item "$yc: double"
.IP "$radius: double" 4
.IX Item "$radius: double"
.IP "$angle1: double" 4
.IX Item "$angle1: double"
.IP "$angle2: double" 4
.IX Item "$angle2: double"
.PD
.PP
$cr\->curve_to ($x1, \f(CW$y1\fR, \f(CW$x2\fR, \f(CW$y2\fR, \f(CW$x3\fR, \f(CW$y3\fR)
.IX Subsection "$cr->curve_to ($x1, $y1, $x2, $y2, $x3, $y3)"
.IP "$x1: double" 4
.IX Item "$x1: double"
.PD 0
.IP "$y1: double" 4
.IX Item "$y1: double"
.IP "$x2: double" 4
.IX Item "$x2: double"
.IP "$y2: double" 4
.IX Item "$y2: double"
.IP "$x3: double" 4
.IX Item "$x3: double"
.IP "$y3: double" 4
.IX Item "$y3: double"
.PD
.PP
$cr\->line_to ($x, \f(CW$y\fR)
.IX Subsection "$cr->line_to ($x, $y)"
.IP "$x: double" 4
.IX Item "$x: double"
.PD 0
.IP "$y: double" 4
.IX Item "$y: double"
.PD
.PP
$cr\->move_to ($x, \f(CW$y\fR)
.IX Subsection "$cr->move_to ($x, $y)"
.IP "$x: double" 4
.IX Item "$x: double"
.PD 0
.IP "$y: double" 4
.IX Item "$y: double"
.PD
.PP
$cr\->rectangle ($x, \f(CW$y\fR, \f(CW$width\fR, \f(CW$height\fR)
.IX Subsection "$cr->rectangle ($x, $y, $width, $height)"
.IP "$x: double" 4
.IX Item "$x: double"
.PD 0
.IP "$y: double" 4
.IX Item "$y: double"
.IP "$width: double" 4
.IX Item "$width: double"
.IP "$height: double" 4
.IX Item "$height: double"
.PD
.PP
$cr\->glyph_path (...)
.IX Subsection "$cr->glyph_path (...)"
.IP "...: list of \fICairo::Glyph\fR's" 4
.IX Item "...: list of Cairo::Glyph's"
.PP
$cr\->text_path ($utf8)
.IX Subsection "$cr->text_path ($utf8)"
.IP "$utf8: string in utf8 encoding" 4
.IX Item "$utf8: string in utf8 encoding"
.PP
$cr\->rel_curve_to ($dx1, \f(CW$dy1\fR, \f(CW$dx2\fR, \f(CW$dy2\fR, \f(CW$dx3\fR, \f(CW$dy3\fR)
.IX Subsection "$cr->rel_curve_to ($dx1, $dy1, $dx2, $dy2, $dx3, $dy3)"
.IP "$dx1: double" 4
.IX Item "$dx1: double"
.PD 0
.IP "$dy1: double" 4
.IX Item "$dy1: double"
.IP "$dx2: double" 4
.IX Item "$dx2: double"
.IP "$dy2: double" 4
.IX Item "$dy2: double"
.IP "$dx3: double" 4
.IX Item "$dx3: double"
.IP "$dy3: double" 4
.IX Item "$dy3: double"
.PD
.PP
$cr\->rel_line_to ($dx, \f(CW$dy\fR)
.IX Subsection "$cr->rel_line_to ($dx, $dy)"
.IP "$dx: double" 4
.IX Item "$dx: double"
.PD 0
.IP "$dy: double" 4
.IX Item "$dy: double"
.PD
.PP
$cr\->rel_move_to ($dx, \f(CW$dy\fR)
.IX Subsection "$cr->rel_move_to ($dx, $dy)"
.IP "$dx: double" 4
.IX Item "$dx: double"
.PD 0
.IP "$dy: double" 4
.IX Item "$dy: double"
.PD
.PP
\fIPatterns \*(-- Gradients and filtered sources\fR
.IX Subsection "Patterns  Gradients and filtered sources"
.PP
$status = \f(CW$pattern\fR\->status
.IX Subsection "$status = $pattern->status"
.PP
$type = \f(CW$pattern\fR\->get_type
.IX Subsection "$type = $pattern->get_type"
.PP
$pattern\->set_matrix ($matrix)
.IX Subsection "$pattern->set_matrix ($matrix)"
.IP "$matrix: \fICairo::Matrix\fR" 4
.IX Item "$matrix: Cairo::Matrix"
.PP
$matrix = \f(CW$pattern\fR\->get_matrix
.IX Subsection "$matrix = $pattern->get_matrix"
.PP
$pattern = Cairo::SolidPattern\->create_rgb ($red, \f(CW$green\fR, \f(CW$blue\fR)
.IX Subsection "$pattern = Cairo::SolidPattern->create_rgb ($red, $green, $blue)"
.IP "$red: double" 4
.IX Item "$red: double"
.PD 0
.IP "$green: double" 4
.IX Item "$green: double"
.IP "$blue: double" 4
.IX Item "$blue: double"
.PD
.PP
$pattern = Cairo::SolidPattern\->create_rgba ($red, \f(CW$green\fR, \f(CW$blue\fR, \f(CW$alpha\fR)
.IX Subsection "$pattern = Cairo::SolidPattern->create_rgba ($red, $green, $blue, $alpha)"
.IP "$red: double" 4
.IX Item "$red: double"
.PD 0
.IP "$green: double" 4
.IX Item "$green: double"
.IP "$blue: double" 4
.IX Item "$blue: double"
.IP "$alpha: double" 4
.IX Item "$alpha: double"
.PD
.PP
$matrix = \f(CW$pattern\fR\->get_matrix
.IX Subsection "$matrix = $pattern->get_matrix"
.PP
$pattern = Cairo::SurfacePattern\->create ($surface)
.IX Subsection "$pattern = Cairo::SurfacePattern->create ($surface)"
.IP "$surface: \fICairo::Surface\fR" 4
.IX Item "$surface: Cairo::Surface"
.PP
$pattern\->set_extend ($extend)
.IX Subsection "$pattern->set_extend ($extend)"
.IP "$extend: \fICairo::Extend\fR" 4
.IX Item "$extend: Cairo::Extend"
.PP
$extend = \f(CW$pattern\fR\->get_extend
.IX Subsection "$extend = $pattern->get_extend"
.PP
$pattern\->set_filter ($filter)
.IX Subsection "$pattern->set_filter ($filter)"
.IP "$filter: \fICairo::Filter\fR" 4
.IX Item "$filter: Cairo::Filter"
.PP
$filter = \f(CW$pattern\fR\->get_filter
.IX Subsection "$filter = $pattern->get_filter"
.PP
$pattern = Cairo::LinearGradient\->create ($x0, \f(CW$y0\fR, \f(CW$x1\fR, \f(CW$y1\fR)
.IX Subsection "$pattern = Cairo::LinearGradient->create ($x0, $y0, $x1, $y1)"
.IP "$x0: double" 4
.IX Item "$x0: double"
.PD 0
.IP "$y0: double" 4
.IX Item "$y0: double"
.IP "$x1: double" 4
.IX Item "$x1: double"
.IP "$y1: double" 4
.IX Item "$y1: double"
.PD
.PP
$pattern = Cairo::RadialGradient\->create ($cx0, \f(CW$cy0\fR, \f(CW$radius0\fR, \f(CW$cx1\fR, \f(CW$cy1\fR, \f(CW$radius1\fR)
.IX Subsection "$pattern = Cairo::RadialGradient->create ($cx0, $cy0, $radius0, $cx1, $cy1, $radius1)"
.IP "$cx0: double" 4
.IX Item "$cx0: double"
.PD 0
.IP "$cy0: double" 4
.IX Item "$cy0: double"
.IP "$radius0: double" 4
.IX Item "$radius0: double"
.IP "$cx1: double" 4
.IX Item "$cx1: double"
.IP "$cy1: double" 4
.IX Item "$cy1: double"
.IP "$radius1: double" 4
.IX Item "$radius1: double"
.PD
.PP
$pattern\->add_color_stop_rgb (double offset, double red, double green, double blue)
.IX Subsection "$pattern->add_color_stop_rgb (double offset, double red, double green, double blue)"
.IP "$offset: double" 4
.IX Item "$offset: double"
.PD 0
.IP "$red: double" 4
.IX Item "$red: double"
.IP "$green: double" 4
.IX Item "$green: double"
.IP "$blue: double" 4
.IX Item "$blue: double"
.PD
.PP
$pattern\->add_color_stop_rgba (double offset, double red, double green, double blue, double alpha)
.IX Subsection "$pattern->add_color_stop_rgba (double offset, double red, double green, double blue, double alpha)"
.IP "$offset: double" 4
.IX Item "$offset: double"
.PD 0
.IP "$red: double" 4
.IX Item "$red: double"
.IP "$green: double" 4
.IX Item "$green: double"
.IP "$blue: double" 4
.IX Item "$blue: double"
.IP "$alpha: double" 4
.IX Item "$alpha: double"
.PD
.PP
\fITransformations \*(-- Manipulating the current transformation matrix\fR
.IX Subsection "Transformations  Manipulating the current transformation matrix"
.PP
$cr\->translate ($tx, \f(CW$ty\fR)
.IX Subsection "$cr->translate ($tx, $ty)"
.IP "$tx: double" 4
.IX Item "$tx: double"
.PD 0
.IP "$ty: double" 4
.IX Item "$ty: double"
.PD
.PP
$cr\->scale ($sx, \f(CW$sy\fR)
.IX Subsection "$cr->scale ($sx, $sy)"
.IP "$sx: double" 4
.IX Item "$sx: double"
.PD 0
.IP "$sy: double" 4
.IX Item "$sy: double"
.PD
.PP
$cr\->rotate ($angle)
.IX Subsection "$cr->rotate ($angle)"
.IP "$angle: double" 4
.IX Item "$angle: double"
.PP
$cr\->transform ($matrix)
.IX Subsection "$cr->transform ($matrix)"
.IP "$matrix: \fICairo::Matrix\fR" 4
.IX Item "$matrix: Cairo::Matrix"
.PP
$cr\->set_matrix ($matrix)
.IX Subsection "$cr->set_matrix ($matrix)"
.IP "$matrix: \fICairo::Matrix\fR" 4
.IX Item "$matrix: Cairo::Matrix"
.PP
$matrix = \f(CW$cr\fR\->get_matrix
.IX Subsection "$matrix = $cr->get_matrix"
.PP
$cr\->identity_matrix
.IX Subsection "$cr->identity_matrix"
.PP
($x, \f(CW$y\fR) = \f(CW$cr\fR\->user_to_device ($x, \f(CW$y\fR)
.IX Subsection "($x, $y) = $cr->user_to_device ($x, $y)"
.IP "$x: double" 4
.IX Item "$x: double"
.PD 0
.IP "$y: double" 4
.IX Item "$y: double"
.PD
.PP
($dx, \f(CW$dy\fR) = \f(CW$cr\fR\->user_to_device_distance ($dx, \f(CW$dy\fR)
.IX Subsection "($dx, $dy) = $cr->user_to_device_distance ($dx, $dy)"
.IP "$dx: double" 4
.IX Item "$dx: double"
.PD 0
.IP "$dy: double" 4
.IX Item "$dy: double"
.PD
.PP
($x, \f(CW$y\fR) = \f(CW$cr\fR\->device_to_user ($x, \f(CW$y\fR)
.IX Subsection "($x, $y) = $cr->device_to_user ($x, $y)"
.IP "$x: double" 4
.IX Item "$x: double"
.PD 0
.IP "$y: double" 4
.IX Item "$y: double"
.PD
.PP
($dx, \f(CW$dy\fR) = \f(CW$cr\fR\->device_to_user_distance ($dx, \f(CW$dy\fR)
.IX Subsection "($dx, $dy) = $cr->device_to_user_distance ($dx, $dy)"
.IP "$dx: double" 4
.IX Item "$dx: double"
.PD 0
.IP "$dy: double" 4
.IX Item "$dy: double"
.PD
.PP
\fIText \*(-- Rendering text and sets of glyphs\fR
.IX Subsection "Text  Rendering text and sets of glyphs"
.PP
Glyphs are represented as anonymous hash references with three keys: \fIindex\fR,
\&\fIx\fR and \fIy\fR.  Example:
.PP
.Vb 3
\&  my @glyphs = ({ index => 1, x => 2, y => 3 },
\&                { index => 2, x => 3, y => 4 },
\&                { index => 3, x => 4, y => 5 });
.Ve
.PP
$cr\->select_font_face ($family, \f(CW$slant\fR, \f(CW$weight\fR)
.IX Subsection "$cr->select_font_face ($family, $slant, $weight)"
.IP "$family: string" 4
.IX Item "$family: string"
.PD 0
.IP "$slant: \fICairo::FontSlant\fR" 4
.IX Item "$slant: Cairo::FontSlant"
.IP "$weight: \fICairo::FontWeight\fR" 4
.IX Item "$weight: Cairo::FontWeight"
.PD
.PP
$cr\->set_font_size ($size)
.IX Subsection "$cr->set_font_size ($size)"
.IP "$size: double" 4
.IX Item "$size: double"
.PP
$cr\->set_font_matrix ($matrix)
.IX Subsection "$cr->set_font_matrix ($matrix)"
.IP "$matrix: \fICairo::Matrix\fR" 4
.IX Item "$matrix: Cairo::Matrix"
.PP
$matrix = \f(CW$cr\fR\->get_font_matrix
.IX Subsection "$matrix = $cr->get_font_matrix"
.PP
$cr\->set_font_options ($options)
.IX Subsection "$cr->set_font_options ($options)"
.IP "$options: \fICairo::FontOptions\fR" 4
.IX Item "$options: Cairo::FontOptions"
.PP
$options = \f(CW$cr\fR\->get_font_options
.IX Subsection "$options = $cr->get_font_options"
.PP
$cr\->set_scaled_font ($scaled_font)
.IX Subsection "$cr->set_scaled_font ($scaled_font)"
.IP "$scaled_font: \fICairo::ScaledFont\fR" 4
.IX Item "$scaled_font: Cairo::ScaledFont"
.PP
$cr\->show_text ($utf8)
.IX Subsection "$cr->show_text ($utf8)"
.IP "$utf8: string" 4
.IX Item "$utf8: string"
.PP
$cr\->show_glyphs (...)
.IX Subsection "$cr->show_glyphs (...)"
.IP "...: list of glyphs" 4
.IX Item "...: list of glyphs"
.PP
$face = \f(CW$cr\fR\->get_font_face
.IX Subsection "$face = $cr->get_font_face"
.PP
$extents = \f(CW$cr\fR\->font_extents
.IX Subsection "$extents = $cr->font_extents"
.PP
$cr\->set_font_face ($font_face)
.IX Subsection "$cr->set_font_face ($font_face)"
.IP "$font_face: \fICairo::FontFace\fR" 4
.IX Item "$font_face: Cairo::FontFace"
.PP
$cr\->set_scaled_font ($scaled_font)
.IX Subsection "$cr->set_scaled_font ($scaled_font)"
.IP "$scaled_font: \fICairo::ScaledFont\fR" 4
.IX Item "$scaled_font: Cairo::ScaledFont"
.PP
$extents = \f(CW$cr\fR\->text_extents ($utf8)
.IX Subsection "$extents = $cr->text_extents ($utf8)"
.IP "$utf8: string" 4
.IX Item "$utf8: string"
.PP
$extents = \f(CW$cr\fR\->glyph_extents (...)
.IX Subsection "$extents = $cr->glyph_extents (...)"
.IP "...: list of glyphs" 4
.IX Item "...: list of glyphs"
.Sh "Fonts"
.IX Subsection "Fonts"
\fICairo::FontFace \*(-- Base class for fonts\fR
.IX Subsection "Cairo::FontFace  Base class for fonts"
.PP
$status = \f(CW$font_face\fR\->status
.IX Subsection "$status = $font_face->status"
.PP
$type = \f(CW$font_face\fR\->get_type
.IX Subsection "$type = $font_face->get_type"
.PP
\fIScaled Fonts \*(-- Caching metrics for a particular font size\fR
.IX Subsection "Scaled Fonts  Caching metrics for a particular font size"
.PP
$scaled_font = Cairo::ScaledFont\->create ($font_face, \f(CW$font_matrix\fR, \f(CW$ctm\fR, \f(CW$options\fR)
.IX Subsection "$scaled_font = Cairo::ScaledFont->create ($font_face, $font_matrix, $ctm, $options)"
.IP "$font_face: \fICairo::FontFace\fR" 4
.IX Item "$font_face: Cairo::FontFace"
.PD 0
.IP "$font_matrix: \fICairo::Matrix\fR" 4
.IX Item "$font_matrix: Cairo::Matrix"
.IP "$ctm: \fICairo::Matrix\fR" 4
.IX Item "$ctm: Cairo::Matrix"
.IP "$options: \fICairo::FontOptions\fR" 4
.IX Item "$options: Cairo::FontOptions"
.PD
.PP
$status = \f(CW$scaled_font\fR\->status
.IX Subsection "$status = $scaled_font->status"
.PP
$extents = \f(CW$scaled_font\fR\->extents
.IX Subsection "$extents = $scaled_font->extents"
.PP
$extents = \f(CW$scaled_font\fR\->text_extents ($utf8)
.IX Subsection "$extents = $scaled_font->text_extents ($utf8)"
.IP "$utf8: string" 4
.IX Item "$utf8: string"
.PP
$extents = \f(CW$scaled_font\fR\->glyph_extents (...)
.IX Subsection "$extents = $scaled_font->glyph_extents (...)"
.IP "...: list of glyphs" 4
.IX Item "...: list of glyphs"
.PP
$font_face = \f(CW$scaled_font\fR\->get_font_face
.IX Subsection "$font_face = $scaled_font->get_font_face"
.PP
$options = \f(CW$scaled_font\fR\->get_font_options
.IX Subsection "$options = $scaled_font->get_font_options"
.PP
$font_matrix = \f(CW$scaled_font\fR\->get_font_matrix
.IX Subsection "$font_matrix = $scaled_font->get_font_matrix"
.PP
$ctm = \f(CW$scaled_font\fR\->get_ctm
.IX Subsection "$ctm = $scaled_font->get_ctm"
.PP
$type = \f(CW$scaled_font\fR\->get_type
.IX Subsection "$type = $scaled_font->get_type"
.PP
\fIFont Options \*(-- How a font should be rendered\fR
.IX Subsection "Font Options  How a font should be rendered"
.PP
$font_options = Cairo::FontOptions\->create
.IX Subsection "$font_options = Cairo::FontOptions->create"
.PP
$status = \f(CW$font_options\fR\->status
.IX Subsection "$status = $font_options->status"
.PP
$font_options\->merge ($other)
.IX Subsection "$font_options->merge ($other)"
.IP "$other: \fICairo::FontOptions\fR" 4
.IX Item "$other: Cairo::FontOptions"
.PP
$hash = \f(CW$font_options\fR\->hash
.IX Subsection "$hash = $font_options->hash"
.PP
$bools = \f(CW$font_options\fR\->equal ($other)
.IX Subsection "$bools = $font_options->equal ($other)"
.IP "$other: \fICairo::FontOptions\fR" 4
.IX Item "$other: Cairo::FontOptions"
.PP
$font_options\->set_antialias ($antialias)
.IX Subsection "$font_options->set_antialias ($antialias)"
.IP "$antialias: \fICairo::AntiAlias\fR" 4
.IX Item "$antialias: Cairo::AntiAlias"
.PP
$antialias = \f(CW$font_options\fR\->get_antialias
.IX Subsection "$antialias = $font_options->get_antialias"
.PP
$font_options\->set_subpixel_order ($subpixel_order)
.IX Subsection "$font_options->set_subpixel_order ($subpixel_order)"
.IP "$subpixel_order: \fICairo::SubpixelOrder\fR" 4
.IX Item "$subpixel_order: Cairo::SubpixelOrder"
.PP
$subpixel_order = \f(CW$font_options\fR\->get_subpixel_order
.IX Subsection "$subpixel_order = $font_options->get_subpixel_order"
.PP
$font_options\->set_hint_style ($hint_style)
.IX Subsection "$font_options->set_hint_style ($hint_style)"
.IP "$hint_style: \fICairo::HintStyle\fR" 4
.IX Item "$hint_style: Cairo::HintStyle"
.PP
$hint_style = \f(CW$font_options\fR\->get_hint_style
.IX Subsection "$hint_style = $font_options->get_hint_style"
.PP
$font_options\->set_hint_metrics ($hint_metrics)
.IX Subsection "$font_options->set_hint_metrics ($hint_metrics)"
.IP "$hint_metrics: \fICairo::HintMetrics\fR" 4
.IX Item "$hint_metrics: Cairo::HintMetrics"
.PP
$hint_metrics = \f(CW$font_options\fR\->get_hint_metrics
.IX Subsection "$hint_metrics = $font_options->get_hint_metrics"
.Sh "Utilities"
.IX Subsection "Utilities"
\fIVersion Information \*(-- Run-time and compile-time version checks.\fR
.IX Subsection "Version Information  Run-time and compile-time version checks."
.PP
$version = Cairo\->version
.IX Subsection "$version = Cairo->version"
.PP
$string = Cairo\->version_string
.IX Subsection "$string = Cairo->version_string"
.PP
$version_code = Cairo\->\s-1VERSION\s0
.IX Subsection "$version_code = Cairo->VERSION"
.PP
$version_code = Cairo\->\s-1VERSION_ENCODE\s0 ($major, \f(CW$minor\fR, \f(CW$micro\fR)
.IX Subsection "$version_code = Cairo->VERSION_ENCODE ($major, $minor, $micro)"
.IP "$major: integer" 4
.IX Item "$major: integer"
.PD 0
.IP "$minor: integer" 4
.IX Item "$minor: integer"
.IP "$micro: integer" 4
.IX Item "$micro: integer"
.PD
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "http://cairographics.org/documentation" 4
.IX Item "http://cairographics.org/documentation"
Lists many available resources including tutorials and examples
.IP "http://cairographics.org/manual/" 4
.IX Item "http://cairographics.org/manual/"
Contains the reference manual
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "Ross McFarland <rwmcfa1 at neces dot com>" 4
.IX Item "Ross McFarland <rwmcfa1 at neces dot com>"
.PD 0
.IP "Torsten Schoenfeld <kaffeetisch at gmx dot de>" 4
.IX Item "Torsten Schoenfeld <kaffeetisch at gmx dot de>"
.PD
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2004\-2006 by the cairo perl team
