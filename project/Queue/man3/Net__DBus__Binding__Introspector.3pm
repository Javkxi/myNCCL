.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::DBus::Binding::Introspector 3pm"
.TH Net::DBus::Binding::Introspector 3pm "2006-11-05" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Net::DBus::Binding::Introspector \- Handler for object introspection data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # Create an object populating with info from an
\&  # XML doc containing introspection data.
.Ve
.PP
.Vb 1
\&  my $ins = Net::DBus::Binding::Introspector\->new(xml => $data);
.Ve
.PP
.Vb 5
\&  # Create an object, defining introspection data
\&  # programmatically
\&  my $ins = Net::DBus::Binding::Introspector\->new(object_path => $object\->get_object_path);
\&  $ins\->add_method("DoSomething", ["string"], [], "org.example.MyObject");
\&  $ins\->add_method("TestSomething", ["int32"], [], "org.example.MyObject");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class is responsible for managing introspection data, and
answering questions about it. This is not intended for use by
application developers, whom should instead consult the higher
level \s-1API\s0 in Net::DBus::Exporter.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "my $ins\fR = Net::DBus::Binding::Introspector\->new(object_path => \f(CW$object_path\fR, xml => \f(CW$xml);" 4
.el .IP "my \f(CW$ins\fR = Net::DBus::Binding::Introspector\->new(object_path => \f(CW$object_path\fR, xml => \f(CW$xml\fR);" 4
.IX Item "my $ins = Net::DBus::Binding::Introspector->new(object_path => $object_path, xml => $xml);"
Creates a new introspection data manager for the object registered
at the path specified for the \f(CW\*(C`object_path\*(C'\fR parameter. The optional
\&\f(CW\*(C`xml\*(C'\fR parameter can be used to pre-load the manager with introspection
metadata from an \s-1XML\s0 document.
.IP "$ins\->add_interface($name)" 4
.IX Item "$ins->add_interface($name)"
Register the object as providing an interface with the name \f(CW$name\fR
.ie n .IP "my $bool\fR = \f(CW$ins\->has_interface($name)" 4
.el .IP "my \f(CW$bool\fR = \f(CW$ins\fR\->has_interface($name)" 4
.IX Item "my $bool = $ins->has_interface($name)"
Return a true value if the object is registered as providing
an interface with the name \f(CW$name\fR; returns false otherwise.
.ie n .IP "my @interfaces\fR = \f(CW$ins\->has_method($name)" 4
.el .IP "my \f(CW@interfaces\fR = \f(CW$ins\fR\->has_method($name)" 4
.IX Item "my @interfaces = $ins->has_method($name)"
Return a list of all interfaces provided by the object, which
contain a method called \f(CW$name\fR. This may be an empty list.
.ie n .IP "my @interfaces\fR = \f(CW$ins\->has_signal($name)" 4
.el .IP "my \f(CW@interfaces\fR = \f(CW$ins\fR\->has_signal($name)" 4
.IX Item "my @interfaces = $ins->has_signal($name)"
Return a list of all interfaces provided by the object, which
contain a signal called \f(CW$name\fR. This may be an empty list.
.ie n .IP "my @interfaces\fR = \f(CW$ins\->has_property($name)" 4
.el .IP "my \f(CW@interfaces\fR = \f(CW$ins\fR\->has_property($name)" 4
.IX Item "my @interfaces = $ins->has_property($name)"
Return a list of all interfaces provided by the object, which
contain a property called \f(CW$name\fR. This may be an empty list.
.ie n .IP "$ins\->add_method($name, $params\fR, \f(CW$returns\fR, \f(CW$interface\fR, \f(CW$attributes);" 4
.el .IP "$ins\->add_method($name, \f(CW$params\fR, \f(CW$returns\fR, \f(CW$interface\fR, \f(CW$attributes\fR);" 4
.IX Item "$ins->add_method($name, $params, $returns, $interface, $attributes);"
Register the object as providing a method called \f(CW$name\fR accepting parameters
whose types are declared by \f(CW$params\fR and returning values whose type
are declared by \f(CW$returns\fR. The method will be scoped to the inteface
named by \f(CW$interface\fR. The \f(CW$attributes\fR parameter is a hash reference
for annotating the method.
.ie n .IP "$ins\->add_signal($name, $params\fR, \f(CW$interface\fR, \f(CW$attributes);" 4
.el .IP "$ins\->add_signal($name, \f(CW$params\fR, \f(CW$interface\fR, \f(CW$attributes\fR);" 4
.IX Item "$ins->add_signal($name, $params, $interface, $attributes);"
Register the object as providing a signal called \f(CW$name\fR with parameters
whose types are declared by \f(CW$params\fR. The signal will be scoped to the inteface
named by \f(CW$interface\fR. The \f(CW$attributes\fR parameter is a hash reference
for annotating the signal.
.ie n .IP "$ins\->add_property($name, $type\fR, \f(CW$access\fR, \f(CW$interface\fR, \f(CW$attributes);" 4
.el .IP "$ins\->add_property($name, \f(CW$type\fR, \f(CW$access\fR, \f(CW$interface\fR, \f(CW$attributes\fR);" 4
.IX Item "$ins->add_property($name, $type, $access, $interface, $attributes);"
Register the object as providing a property called \f(CW$name\fR with a type
of \f(CW$type\fR. The \f(CW$access\fR parameter can be one of \f(CW\*(C`read\*(C'\fR, \f(CW\*(C`write\*(C'\fR,
or \f(CW\*(C`readwrite\*(C'\fR. The property will be scoped to the inteface
named by \f(CW$interface\fR. The \f(CW$attributes\fR parameter is a hash reference
for annotating the signal.
.ie n .IP "my $boolean\fR = \f(CW$ins\fR\->is_method_deprecated($name, \f(CW$interface)" 4
.el .IP "my \f(CW$boolean\fR = \f(CW$ins\fR\->is_method_deprecated($name, \f(CW$interface\fR)" 4
.IX Item "my $boolean = $ins->is_method_deprecated($name, $interface)"
Returns a true value if the method called \f(CW$name\fR in the interface
\&\f(CW$interface\fR is marked as deprecated
.ie n .IP "my $boolean\fR = \f(CW$ins\fR\->is_signal_deprecated($name, \f(CW$interface)" 4
.el .IP "my \f(CW$boolean\fR = \f(CW$ins\fR\->is_signal_deprecated($name, \f(CW$interface\fR)" 4
.IX Item "my $boolean = $ins->is_signal_deprecated($name, $interface)"
Returns a true value if the signal called \f(CW$name\fR in the interface
\&\f(CW$interface\fR is marked as deprecated
.ie n .IP "my $boolean\fR = \f(CW$ins\fR\->is_property_deprecated($name, \f(CW$interface)" 4
.el .IP "my \f(CW$boolean\fR = \f(CW$ins\fR\->is_property_deprecated($name, \f(CW$interface\fR)" 4
.IX Item "my $boolean = $ins->is_property_deprecated($name, $interface)"
Returns a true value if the property called \f(CW$name\fR in the interface
\&\f(CW$interface\fR is marked as deprecated
.ie n .IP "my $boolean\fR = \f(CW$ins\fR\->does_method_reply($name, \f(CW$interface)" 4
.el .IP "my \f(CW$boolean\fR = \f(CW$ins\fR\->does_method_reply($name, \f(CW$interface\fR)" 4
.IX Item "my $boolean = $ins->does_method_reply($name, $interface)"
Returns a true value if the method called \f(CW$name\fR in the interface
\&\f(CW$interface\fR will generate a reply. Returns a false value otherwise.
.ie n .IP "my @names\fR = \f(CW$ins\->list_interfaces" 4
.el .IP "my \f(CW@names\fR = \f(CW$ins\fR\->list_interfaces" 4
.IX Item "my @names = $ins->list_interfaces"
Returns a list of all interfaces registered as being provided
by the object.
.ie n .IP "my @names\fR = \f(CW$ins\->list_methods($interface)" 4
.el .IP "my \f(CW@names\fR = \f(CW$ins\fR\->list_methods($interface)" 4
.IX Item "my @names = $ins->list_methods($interface)"
Returns a list of all methods registered as being provided
by the object, within the interface \f(CW$interface\fR.
.ie n .IP "my @names\fR = \f(CW$ins\->list_signals($interface)" 4
.el .IP "my \f(CW@names\fR = \f(CW$ins\fR\->list_signals($interface)" 4
.IX Item "my @names = $ins->list_signals($interface)"
Returns a list of all signals registered as being provided
by the object, within the interface \f(CW$interface\fR.
.ie n .IP "my @names\fR = \f(CW$ins\->list_properties($interface)" 4
.el .IP "my \f(CW@names\fR = \f(CW$ins\fR\->list_properties($interface)" 4
.IX Item "my @names = $ins->list_properties($interface)"
Returns a list of all properties registered as being provided
by the object, within the interface \f(CW$interface\fR.
.ie n .IP "my @paths\fR = \f(CW$self\->list_children;" 4
.el .IP "my \f(CW@paths\fR = \f(CW$self\fR\->list_children;" 4
.IX Item "my @paths = $self->list_children;"
Returns a list of object paths representing all the children
of this node.
.ie n .IP "my $path\fR = \f(CW$ins\->get_object_path" 4
.el .IP "my \f(CW$path\fR = \f(CW$ins\fR\->get_object_path" 4
.IX Item "my $path = $ins->get_object_path"
Returns the path of the object associated with this introspection
data
.ie n .IP "my @types\fR = \f(CW$ins\fR\->get_method_params($interface, \f(CW$name)" 4
.el .IP "my \f(CW@types\fR = \f(CW$ins\fR\->get_method_params($interface, \f(CW$name\fR)" 4
.IX Item "my @types = $ins->get_method_params($interface, $name)"
Returns a list of declared data types for parameters of the
method called \f(CW$name\fR within the interface \f(CW$interface\fR.
.ie n .IP "my @types\fR = \f(CW$ins\fR\->get_method_returns($interface, \f(CW$name)" 4
.el .IP "my \f(CW@types\fR = \f(CW$ins\fR\->get_method_returns($interface, \f(CW$name\fR)" 4
.IX Item "my @types = $ins->get_method_returns($interface, $name)"
Returns a list of declared data types for return values of the
method called \f(CW$name\fR within the interface \f(CW$interface\fR.
.ie n .IP "my @types\fR = \f(CW$ins\fR\->get_signal_params($interface, \f(CW$name)" 4
.el .IP "my \f(CW@types\fR = \f(CW$ins\fR\->get_signal_params($interface, \f(CW$name\fR)" 4
.IX Item "my @types = $ins->get_signal_params($interface, $name)"
Returns a list of declared data types for values associated with the
signal called \f(CW$name\fR within the interface \f(CW$interface\fR.
.ie n .IP "my $type\fR = \f(CW$ins\fR\->get_property_type($interface, \f(CW$name)" 4
.el .IP "my \f(CW$type\fR = \f(CW$ins\fR\->get_property_type($interface, \f(CW$name\fR)" 4
.IX Item "my $type = $ins->get_property_type($interface, $name)"
Returns the declared data type for property called \f(CW$name\fR within
the interface \f(CW$interface\fR.
.ie n .IP "my $bool\fR = \f(CW$ins\fR\->is_property_readable($interface, \f(CW$name);" 4
.el .IP "my \f(CW$bool\fR = \f(CW$ins\fR\->is_property_readable($interface, \f(CW$name\fR);" 4
.IX Item "my $bool = $ins->is_property_readable($interface, $name);"
Returns a true value if the property called \f(CW$name\fR within the
interface \f(CW$interface\fR can have its value read.
.ie n .IP "my $bool\fR = \f(CW$ins\fR\->is_property_writable($interface, \f(CW$name);" 4
.el .IP "my \f(CW$bool\fR = \f(CW$ins\fR\->is_property_writable($interface, \f(CW$name\fR);" 4
.IX Item "my $bool = $ins->is_property_writable($interface, $name);"
Returns a true value if the property called \f(CW$name\fR within the
interface \f(CW$interface\fR can have its value written to.
.ie n .IP "my $xml\fR = \f(CW$ins\->format" 4
.el .IP "my \f(CW$xml\fR = \f(CW$ins\fR\->format" 4
.IX Item "my $xml = $ins->format"
Return a string containing an \s-1XML\s0 document representing the
state of the introspection data.
.ie n .IP "my $xml_fragment\fR = \f(CW$ins\->to_xml" 4
.el .IP "my \f(CW$xml_fragment\fR = \f(CW$ins\fR\->to_xml" 4
.IX Item "my $xml_fragment = $ins->to_xml"
Returns a string containing an \s-1XML\s0 fragment representing the
state of the introspection data. This is basically the same
as the \f(CW\*(C`format\*(C'\fR method, but without the leading doctype
declaration.
.ie n .IP "$type = $ins\->to_xml_type($type)" 4
.el .IP "$type = \f(CW$ins\fR\->to_xml_type($type)" 4
.IX Item "$type = $ins->to_xml_type($type)"
Takes a text-based representation of a data type and returns
the compact representation used in \s-1XML\s0 introspection data.
.ie n .IP "$ins\->encode($message, $type\fR, \f(CW$name\fR, \f(CW$direction\fR, \f(CW@args)" 4
.el .IP "$ins\->encode($message, \f(CW$type\fR, \f(CW$name\fR, \f(CW$direction\fR, \f(CW@args\fR)" 4
.IX Item "$ins->encode($message, $type, $name, $direction, @args)"
Append a set of values <@args> to a message object \f(CW$message\fR.
The \f(CW$type\fR parameter is either \f(CW\*(C`signal\*(C'\fR or \f(CW\*(C`method\*(C'\fR and
\&\f(CW$direction\fR is either \f(CW\*(C`params\*(C'\fR or \f(CW\*(C`returns\*(C'\fR. The introspection
data will be queried to obtain the declared data types & the
argument marshalling accordingly.
.ie n .IP "my @args\fR = \f(CW$ins\fR\->decode($message, \f(CW$type\fR, \f(CW$name\fR, \f(CW$direction)" 4
.el .IP "my \f(CW@args\fR = \f(CW$ins\fR\->decode($message, \f(CW$type\fR, \f(CW$name\fR, \f(CW$direction\fR)" 4
.IX Item "my @args = $ins->decode($message, $type, $name, $direction)"
Unmarshalls the contents of a message object \f(CW$message\fR.
The \f(CW$type\fR parameter is either \f(CW\*(C`signal\*(C'\fR or \f(CW\*(C`method\*(C'\fR and
\&\f(CW$direction\fR is either \f(CW\*(C`params\*(C'\fR or \f(CW\*(C`returns\*(C'\fR. The introspection
data will be queried to obtain the declared data types & the
arguments unmarshalled accordingly.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::DBus::Exporter, Net::DBus::Binding::Message
.SH "AUTHOR"
.IX Header "AUTHOR"
Daniel Berrange <dan@berrange.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2004 by Daniel Berrange
