.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Glib::BookmarkFile 3pm"
.TH Glib::BookmarkFile 3pm "2007-03-05" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Glib::BookmarkFile \-  Parser for bookmark files
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Glib;
.Ve
.PP
.Vb 1
\&  $date .= $_ while (<DATA>);
.Ve
.PP
.Vb 6
\&  $b = Glib::BookmarkFile\->new;
\&  $b\->load_from_data($data);
\&  $uri = 'file:///some/path/to/a/file.txt';
\&  if ($b\->has_item($uri)) {
\&        $title = $b\->get_title($uri);
\&        $desc  = $b\->get_description($uri);
.Ve
.PP
.Vb 4
\&        print "Bookmark for `$uri' ($title):\en";
\&        print "  $desc\en";
\&  }
\&  0;
.Ve
.PP
.Vb 19
\&  __DATA__
\&  <?xml version="1.0" encoding="UTF\-8"?>
\&  <xbel version="1.0"
\&        xmlns:bookmark="http://www.freedesktop.org/standards/desktop\-bookmarks"
\&        xmlns:mime="http://www.freedesktop.org/standards/shared\-mime\-info"
\&>
\&    <bookmark href="file:///tmp/test\-file.txt" added="2006\-03\-22T18:54:00Z" modified="2006\-03\-22T18:54:00Z" visited="2006\-03\-22T18:54:00Z">
\&      <title>Test File</title>
\&      <desc>Some test file</desc>
\&      <info>
\&        <metadata owner="http://freedesktop.org">
\&          <mime:mime\-type type="text/plain"/>
\&          <bookmark:applications>
\&            <bookmark:application name="Gedit" exec="gedit %u" timestamp="1143053640" count="1"/>
\&          </bookmark:applications>
\&        </metadata>
\&      </info>
\&    </bookmark>
\&  </xbel>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBGlib::BookmarkFile\fR lets you parse, edit or create files containing lists
of bookmarks to resources pointed to by URIs, with some meta-data bound to
them, following the Desktop Bookmark Specification.  The recent files support
inside \s-1GTK+\s0 uses this type of files to store the list of recently used
files.
.PP
The syntax of bookmark files is described in detail in the Desktop Bookmarks
Specification, here is a quick summary: bookmark files use a subclass of the
\&\s-1XML\s0 Bookmark Exchange Language (\s-1XBEL\s0) document format, defining meta-data
such as the \s-1MIME\s0 type of the resource pointed by a bookmark, the list of
applications that have registered the same \s-1URI\s0 and the visibility of the
bookmark.
.SH "METHODS"
.IX Header "METHODS"
.Sh "bookmarkfile = Glib::BookmarkFile\->\fBnew\fP"
.IX Subsection "bookmarkfile = Glib::BookmarkFile->new"
.ie n .Sh "$bookmark_file\->\fBadd_application\fP ($uri, $name\fP, \f(CW$exec)"
.el .Sh "$bookmark_file\->\fBadd_application\fP ($uri, \f(CW$name\fP, \f(CW$exec\fP)"
.IX Subsection "$bookmark_file->add_application ($uri, $name, $exec)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.PD 0
.ie n .IP "* $name (string or undef)" 4
.el .IP "* \f(CW$name\fR (string or undef)" 4
.IX Item "$name (string or undef)"
.ie n .IP "* $exec (string or undef)" 4
.el .IP "* \f(CW$exec\fR (string or undef)" 4
.IX Item "$exec (string or undef)"
.RE
.RS 4
.PD
.Sp
Adds the application with \f(CW$name\fR and \f(CW$exec\fR to the list of
applications that have registered a bookmark for \f(CW$uri\fR into
\&\f(CW$bookmark_file\fR.
.Sp
Every bookmark inside a \f(CW\*(C`Glib::BookmarkFile\*(C'\fR must have at least an
application registered.  Each application must provide a name, a
command line useful for launching the bookmark, the number of times
the bookmark has been registered by the application and the last
time the application registered this bookmark.
.Sp
If \f(CW$name\fR is undef, the name of the application will be the
same returned by \fIGlib::get_application_name()\fR; if \f(CW$exec\fR is undef,
the command line will be a composition of the program name as
returned by \fIGlib::get_prgname()\fR and the \*(L"%u\*(R" modifier, which will
be expanded to the bookmark's \s-1URI\s0.
.Sp
This function will automatically take care of updating the
registrations count and timestamping in case an application
with the same \f(CW$name\fR had already registered a bookmark for
\&\f(CW$uri\fR inside the bookmark file.  If no bookmark for \f(CW$uri\fR is found
one is created.
.RE
.ie n .Sh "$bookmark_file\->\fBadd_group\fP ($uri, $group)"
.el .Sh "$bookmark_file\->\fBadd_group\fP ($uri, \f(CW$group\fP)"
.IX Subsection "$bookmark_file->add_group ($uri, $group)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.PD 0
.ie n .IP "* $group (string)" 4
.el .IP "* \f(CW$group\fR (string)" 4
.IX Item "$group (string)"
.RE
.RS 4
.PD
.Sp
Adds \f(CW$group\fR to the list of groups to which the bookmark for \f(CW$uri\fR
belongs to.  If no bookmark for \f(CW$uri\fR is found one is created.
.RE
.ie n .Sh "unix timestamp = $bookmark_file\fP\->\fBget_added ($uri)"
.el .Sh "unix timestamp = \f(CW$bookmark_file\fP\->\fBget_added\fP ($uri)"
.IX Subsection "unix timestamp = $bookmark_file->get_added ($uri)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.RE
.RS 4
.RE
.ie n .Sh "Glib::BookmarkFile::set_added ($bookmark_file, $uri\fP, \f(CW$value)"
.el .Sh "Glib::BookmarkFile::set_added ($bookmark_file, \f(CW$uri\fP, \f(CW$value\fP)"
.IX Subsection "Glib::BookmarkFile::set_added ($bookmark_file, $uri, $value)"
.RS 4
.PD 0
.ie n .IP "* $bookmark_file (Glib::BookmarkFile)" 4
.el .IP "* \f(CW$bookmark_file\fR (Glib::BookmarkFile)" 4
.IX Item "$bookmark_file (Glib::BookmarkFile)"
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.ie n .IP "* $value (unix timestamp)" 4
.el .IP "* \f(CW$value\fR (unix timestamp)" 4
.IX Item "$value (unix timestamp)"
.RE
.RS 4
.PD
.Sp
Sets the time the bookmark for \f(CW$uri\fR was added.
If no bookmark for \f(CW$uri\fR is found one is created.
.RE
.ie n .Sh "($exec, $count\fP, \f(CW$stamp\fP) = \f(CW$bookmark_file\fP\->\fBget_app_info\fP ($uri, \f(CW$name)"
.el .Sh "($exec, \f(CW$count\fP, \f(CW$stamp\fP) = \f(CW$bookmark_file\fP\->\fBget_app_info\fP ($uri, \f(CW$name\fP)"
.IX Subsection "($exec, $count, $stamp) = $bookmark_file->get_app_info ($uri, $name)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.PD 0
.ie n .IP "* $name (string)" 4
.el .IP "* \f(CW$name\fR (string)" 4
.IX Item "$name (string)"
.RE
.RS 4
.PD
.Sp
Gets the registration informations of \f(CW$name\fR for the bookmark for
\&\f(CW$uri\fR.  See \fIGlib::BookmarkFile::set_app_info()\fR for more informations about
the returned data.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$bookmark_file\->\fBset_app_info\fP ($uri, $name\fP, \f(CW$exec\fP, \f(CW$count\fP, \f(CW$stamp)"
.el .Sh "$bookmark_file\->\fBset_app_info\fP ($uri, \f(CW$name\fP, \f(CW$exec\fP, \f(CW$count\fP, \f(CW$stamp\fP)"
.IX Subsection "$bookmark_file->set_app_info ($uri, $name, $exec, $count, $stamp)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.PD 0
.ie n .IP "* $name (string)" 4
.el .IP "* \f(CW$name\fR (string)" 4
.IX Item "$name (string)"
.ie n .IP "* $exec (string)" 4
.el .IP "* \f(CW$exec\fR (string)" 4
.IX Item "$exec (string)"
.ie n .IP "* $count (integer)" 4
.el .IP "* \f(CW$count\fR (integer)" 4
.IX Item "$count (integer)"
.ie n .IP "* $stamp (unix timestamp)" 4
.el .IP "* \f(CW$stamp\fR (unix timestamp)" 4
.IX Item "$stamp (unix timestamp)"
.RE
.RS 4
.PD
.Sp
Sets the meta-data of application \f(CW$name\fR inside the list of
applications that have registered a bookmark for \f(CW$uri\fR inside
\&\f(CW$bookmark_file\fR.
.Sp
You should rarely use this method; use \fIGlib::BookmarkFile::add_application()\fR
and \fIGlib::BookmarkFile::remove_application()\fR instead.
.Sp
$name can be any \s-1UTF\-8\s0 encoded string used to identify an application.
\&\f(CW$exec\fR can have one of these two modifiers: \*(L"%f\*(R", which will be expanded
as the local file name retrieved from the bookmark's \s-1URI\s0; \*(L"%u\*(R", which
will be expanded as the bookmark's \s-1URI\s0. The expansion is done automatically
when retrieving the stored command line using the
\&\fIGlib::BookmarkFile::get_app_info()\fR method.
\&\f(CW$count\fR is the number of times the application has registered the
bookmark; if it is < 0, the current registration count will be increased
by one, if it is 0, the application with \f(CW$name\fR will be removed from
the list of registered applications.
\&\f(CW$stamp\fR is the Unix time of the last registration, as returned by \fItime()\fR; if
it is \-1, the current time will be used.
.Sp
If you try to remove an application by setting its registration count to
zero, and no bookmark for \f(CW$uri\fR is found, \f(CW%FALSE\fR is returned and an
exception is fired.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "list = $bookmark_file\fP\->\fBget_applications ($uri)"
.el .Sh "list = \f(CW$bookmark_file\fP\->\fBget_applications\fP ($uri)"
.IX Subsection "list = $bookmark_file->get_applications ($uri)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.RE
.RS 4
.Sp
Retrieves the names of the applications that have registered the
bookmark for \f(CW$uri\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.Sh "$bookmark_file\->\fBget_description\fP ($uri)"
.IX Subsection "$bookmark_file->get_description ($uri)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.RE
.RS 4
.Sp
Gets the description of the bookmark for \f(CW$uri\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$bookmark_file\->\fBset_description\fP ($uri, $description)"
.el .Sh "$bookmark_file\->\fBset_description\fP ($uri, \f(CW$description\fP)"
.IX Subsection "$bookmark_file->set_description ($uri, $description)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.PD 0
.ie n .IP "* $description (string)" 4
.el .IP "* \f(CW$description\fR (string)" 4
.IX Item "$description (string)"
.RE
.RS 4
.PD
.Sp
Sets the description of the bookmark for \f(CW$uri\fR.  If no bookmark for \f(CW$uri\fR
is found one is created.
.RE
.ie n .Sh "list = $bookmark_file\fP\->\fBget_groups ($uri)"
.el .Sh "list = \f(CW$bookmark_file\fP\->\fBget_groups\fP ($uri)"
.IX Subsection "list = $bookmark_file->get_groups ($uri)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.RE
.RS 4
.Sp
Retrieves the list of group names of the bookmark for \f(CW$uri\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.Sh "$bookmark_file\->\fBset_groups\fP ($uri, ...)"
.IX Subsection "$bookmark_file->set_groups ($uri, ...)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.PD 0
.IP "* ... (list) one or more group names" 4
.IX Item "... (list) one or more group names"
.RE
.RS 4
.PD
.Sp
Sets a list of group names for the item with \s-1URI\s0 \f(CW$uri\fR.  Each previously
set group name list is removed.  If no bookmark for \f(CW$uri\fR is found one
is created.
.RE
.ie n .Sh "boolean = $bookmark_file\fP\->\fBhas_application\fP ($uri, \f(CW$name)"
.el .Sh "boolean = \f(CW$bookmark_file\fP\->\fBhas_application\fP ($uri, \f(CW$name\fP)"
.IX Subsection "boolean = $bookmark_file->has_application ($uri, $name)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.PD 0
.ie n .IP "* $name (string)" 4
.el .IP "* \f(CW$name\fR (string)" 4
.IX Item "$name (string)"
.RE
.RS 4
.PD
.Sp
Checks whether the bookmark for \f(CW$uri\fR inside \f(CW$bookmark_file\fR has
been registered by application \f(CW$name\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "boolean = $bookmark_file\fP\->\fBhas_group\fP ($uri, \f(CW$group)"
.el .Sh "boolean = \f(CW$bookmark_file\fP\->\fBhas_group\fP ($uri, \f(CW$group\fP)"
.IX Subsection "boolean = $bookmark_file->has_group ($uri, $group)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.PD 0
.ie n .IP "* $group (string)" 4
.el .IP "* \f(CW$group\fR (string)" 4
.IX Item "$group (string)"
.RE
.RS 4
.PD
.Sp
Checks whether \f(CW$group\fR appears in the list of groups to which
the bookmark for \f(CW$uri\fR belongs to.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "boolean = $bookmark_file\fP\->\fBhas_item ($uri)"
.el .Sh "boolean = \f(CW$bookmark_file\fP\->\fBhas_item\fP ($uri)"
.IX Subsection "boolean = $bookmark_file->has_item ($uri)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.RE
.RS 4
.Sp
Looks whether the bookmark file has a bookmark for \f(CW$uri\fR.
.RE
.ie n .Sh "($href, $mime_type\fP) = \f(CW$bookmark_file\fP\->\fBget_icon ($uri)"
.el .Sh "($href, \f(CW$mime_type\fP) = \f(CW$bookmark_file\fP\->\fBget_icon\fP ($uri)"
.IX Subsection "($href, $mime_type) = $bookmark_file->get_icon ($uri)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.RE
.RS 4
.Sp
Gets the icon of the bookmark for \f(CW$uri\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$bookmark_file\->\fBset_icon\fP ($uri, $href\fP, \f(CW$mime_type)"
.el .Sh "$bookmark_file\->\fBset_icon\fP ($uri, \f(CW$href\fP, \f(CW$mime_type\fP)"
.IX Subsection "$bookmark_file->set_icon ($uri, $href, $mime_type)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.PD 0
.ie n .IP "* $href (string or undef)" 4
.el .IP "* \f(CW$href\fR (string or undef)" 4
.IX Item "$href (string or undef)"
.ie n .IP "* $mime_type (string or undef)" 4
.el .IP "* \f(CW$mime_type\fR (string or undef)" 4
.IX Item "$mime_type (string or undef)"
.RE
.RS 4
.PD
.Sp
Sets the icon for the bookmark for \f(CW$uri\fR.  If \f(CW$href\fR is undef, unsets
the currently set icon.
.RE
.ie n .Sh "boolean = $bookmark_file\fP\->\fBget_is_private ($uri)"
.el .Sh "boolean = \f(CW$bookmark_file\fP\->\fBget_is_private\fP ($uri)"
.IX Subsection "boolean = $bookmark_file->get_is_private ($uri)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.RE
.RS 4
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$bookmark_file\->\fBset_is_private\fP ($uri, $is_private)"
.el .Sh "$bookmark_file\->\fBset_is_private\fP ($uri, \f(CW$is_private\fP)"
.IX Subsection "$bookmark_file->set_is_private ($uri, $is_private)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.PD 0
.ie n .IP "* $is_private (boolean)" 4
.el .IP "* \f(CW$is_private\fR (boolean)" 4
.IX Item "$is_private (boolean)"
.RE
.RS 4
.RE
.PD
.Sh "$bookmark_file\->\fBload_from_data\fP ($buf)"
.IX Subsection "$bookmark_file->load_from_data ($buf)"
.RS 4
.ie n .IP "* $buf (scalar)" 4
.el .IP "* \f(CW$buf\fR (scalar)" 4
.IX Item "$buf (scalar)"
.RE
.RS 4
.Sp
Parses a string containing a bookmark file structure.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "($full_path) = $bookmark_file\fP\->\fBload_from_data_dirs ($file)"
.el .Sh "($full_path) = \f(CW$bookmark_file\fP\->\fBload_from_data_dirs\fP ($file)"
.IX Subsection "($full_path) = $bookmark_file->load_from_data_dirs ($file)"
.RS 4
.ie n .IP "* $file (localized file name)" 4
.el .IP "* \f(CW$file\fR (localized file name)" 4
.IX Item "$file (localized file name)"
.RE
.RS 4
.Sp
Parses a bookmark file, searching for it inside the data directories.
If a file is found, it returns the full path.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.Sh "$bookmark_file\->\fBload_from_file\fP ($file)"
.IX Subsection "$bookmark_file->load_from_file ($file)"
.RS 4
.ie n .IP "* $file (localized file name)" 4
.el .IP "* \f(CW$file\fR (localized file name)" 4
.IX Item "$file (localized file name)"
.RE
.RS 4
.Sp
Parses a bookmark file.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "string = $bookmark_file\fP\->\fBget_mime_type ($uri)"
.el .Sh "string = \f(CW$bookmark_file\fP\->\fBget_mime_type\fP ($uri)"
.IX Subsection "string = $bookmark_file->get_mime_type ($uri)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.RE
.RS 4
.Sp
Gets the \s-1MIME\s0 type of the bookmark for \f(CW$uri\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$bookmark_file\->\fBset_mime_type\fP ($uri, $mime_type)"
.el .Sh "$bookmark_file\->\fBset_mime_type\fP ($uri, \f(CW$mime_type\fP)"
.IX Subsection "$bookmark_file->set_mime_type ($uri, $mime_type)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.PD 0
.ie n .IP "* $mime_type (string)" 4
.el .IP "* \f(CW$mime_type\fR (string)" 4
.IX Item "$mime_type (string)"
.RE
.RS 4
.PD
.Sp
Sets the \s-1MIME\s0 type of the bookmark for \f(CW$uri\fR.  If no bookmark for \f(CW$uri\fR
is found one is created.
.RE
.ie n .Sh "unix timestamp = $bookmark_file\fP\->\fBget_modified ($uri)"
.el .Sh "unix timestamp = \f(CW$bookmark_file\fP\->\fBget_modified\fP ($uri)"
.IX Subsection "unix timestamp = $bookmark_file->get_modified ($uri)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.RE
.RS 4
.RE
.ie n .Sh "Glib::BookmarkFile::set_modified ($bookmark_file, $uri\fP, \f(CW$value)"
.el .Sh "Glib::BookmarkFile::set_modified ($bookmark_file, \f(CW$uri\fP, \f(CW$value\fP)"
.IX Subsection "Glib::BookmarkFile::set_modified ($bookmark_file, $uri, $value)"
.RS 4
.PD 0
.ie n .IP "* $bookmark_file (Glib::BookmarkFile)" 4
.el .IP "* \f(CW$bookmark_file\fR (Glib::BookmarkFile)" 4
.IX Item "$bookmark_file (Glib::BookmarkFile)"
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.ie n .IP "* $value (unix timestamp)" 4
.el .IP "* \f(CW$value\fR (unix timestamp)" 4
.IX Item "$value (unix timestamp)"
.RE
.RS 4
.PD
.Sp
Sets the time the bookmark for \f(CW$uri\fR was last modified.
If no bookmark for \f(CW$uri\fR is found one is created.
.RE
.ie n .Sh "$bookmark_file\->\fBmove_item\fP ($old_uri, $new_uri)"
.el .Sh "$bookmark_file\->\fBmove_item\fP ($old_uri, \f(CW$new_uri\fP)"
.IX Subsection "$bookmark_file->move_item ($old_uri, $new_uri)"
.RS 4
.ie n .IP "* $old_uri (string)" 4
.el .IP "* \f(CW$old_uri\fR (string)" 4
.IX Item "$old_uri (string)"
.PD 0
.ie n .IP "* $new_uri (string or undef)" 4
.el .IP "* \f(CW$new_uri\fR (string or undef)" 4
.IX Item "$new_uri (string or undef)"
.RE
.RS 4
.PD
.Sp
Changes the \s-1URI\s0 of a bookmark item from \f(CW$old_uri\fR to \f(CW$new_uri\fR.  Any
existing bookmark for \f(CW$new_uri\fR will be overwritten.  If \f(CW$new_uri\fR is
undef, then the bookmark is removed.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$bookmark_file\->\fBremove_application\fP ($uri, $name)"
.el .Sh "$bookmark_file\->\fBremove_application\fP ($uri, \f(CW$name\fP)"
.IX Subsection "$bookmark_file->remove_application ($uri, $name)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.PD 0
.ie n .IP "* $name (string)" 4
.el .IP "* \f(CW$name\fR (string)" 4
.IX Item "$name (string)"
.RE
.RS 4
.PD
.Sp
Removes application registered with \f(CW$name\fR from the list of applications
that have registered a bookmark for \f(CW$uri\fR inside \f(CW$bookmark_file\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$bookmark_file\->\fBremove_group\fP ($uri, $group)"
.el .Sh "$bookmark_file\->\fBremove_group\fP ($uri, \f(CW$group\fP)"
.IX Subsection "$bookmark_file->remove_group ($uri, $group)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.PD 0
.ie n .IP "* $group (string)" 4
.el .IP "* \f(CW$group\fR (string)" 4
.IX Item "$group (string)"
.RE
.RS 4
.PD
.Sp
Removes \f(CW$group\fR from the list of groups to which the bookmark
for \f(CW$uri\fR belongs to.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "boolean = $bookmark_file\fP\->\fBremove_item ($uri)"
.el .Sh "boolean = \f(CW$bookmark_file\fP\->\fBremove_item\fP ($uri)"
.IX Subsection "boolean = $bookmark_file->remove_item ($uri)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.RE
.RS 4
.Sp
Removes the bookmark for \f(CW$uri\fR from the bookmark file.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "integer = $bookmark_file\fP\->\fBget_size"
.el .Sh "integer = \f(CW$bookmark_file\fP\->\fBget_size\fP"
.IX Subsection "integer = $bookmark_file->get_size"
.RS 4
Gets the number of bookmarks inside the bookmark file.
.RE
.ie n .Sh "$bookmark_file\->\fBget_title\fP ($uri, $title)"
.el .Sh "$bookmark_file\->\fBget_title\fP ($uri, \f(CW$title\fP)"
.IX Subsection "$bookmark_file->get_title ($uri, $title)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.RE
.RS 4
.Sp
Gets the title of the bookmark for \f(CW$uri\fR.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "$bookmark_file\->\fBset_title\fP ($uri, $title)"
.el .Sh "$bookmark_file\->\fBset_title\fP ($uri, \f(CW$title\fP)"
.IX Subsection "$bookmark_file->set_title ($uri, $title)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.PD 0
.ie n .IP "* $title (string)" 4
.el .IP "* \f(CW$title\fR (string)" 4
.IX Item "$title (string)"
.RE
.RS 4
.PD
.Sp
Sets the title of the bookmark for \f(CW$uri\fR.  If no bookmark for \f(CW$uri\fR is found
one is created.
.RE
.ie n .Sh "string = $bookmark_file\fP\->\fBto_data"
.el .Sh "string = \f(CW$bookmark_file\fP\->\fBto_data\fP"
.IX Subsection "string = $bookmark_file->to_data"
.RS 4
Returns the bookmark file as a string.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.Sh "$bookmark_file\->\fBto_file\fP ($file)"
.IX Subsection "$bookmark_file->to_file ($file)"
.RS 4
.ie n .IP "* $file (localized file name)" 4
.el .IP "* \f(CW$file\fR (localized file name)" 4
.IX Item "$file (localized file name)"
.RE
.RS 4
.Sp
Saves the contents of a bookmark file into a file.  The write operation
is guaranteed to be atomical by writing the contents of the bookmark file
to a temporary file and then moving the file to the target file.
.Sp
May croak with a Glib::Error in $@ on failure.
.RE
.ie n .Sh "list = $bookmark_file\fP\->\fBget_uris"
.el .Sh "list = \f(CW$bookmark_file\fP\->\fBget_uris\fP"
.IX Subsection "list = $bookmark_file->get_uris"
.RS 4
Returns the \s-1URI\s0 of all the bookmarks in the bookmark file.
.RE
.ie n .Sh "unix timestamp = $bookmark_file\fP\->\fBget_visited ($uri)"
.el .Sh "unix timestamp = \f(CW$bookmark_file\fP\->\fBget_visited\fP ($uri)"
.IX Subsection "unix timestamp = $bookmark_file->get_visited ($uri)"
.RS 4
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.RE
.RS 4
.RE
.ie n .Sh "Glib::BookmarkFile::set_visited ($bookmark_file, $uri\fP, \f(CW$value)"
.el .Sh "Glib::BookmarkFile::set_visited ($bookmark_file, \f(CW$uri\fP, \f(CW$value\fP)"
.IX Subsection "Glib::BookmarkFile::set_visited ($bookmark_file, $uri, $value)"
.RS 4
.PD 0
.ie n .IP "* $bookmark_file (Glib::BookmarkFile)" 4
.el .IP "* \f(CW$bookmark_file\fR (Glib::BookmarkFile)" 4
.IX Item "$bookmark_file (Glib::BookmarkFile)"
.ie n .IP "* $uri (string)" 4
.el .IP "* \f(CW$uri\fR (string)" 4
.IX Item "$uri (string)"
.ie n .IP "* $value (unix timestamp)" 4
.el .IP "* \f(CW$value\fR (unix timestamp)" 4
.IX Item "$value (unix timestamp)"
.RE
.RS 4
.PD
.Sp
Sets the time the bookmark for \f(CW$uri\fR was last visited.
If no bookmark for \f(CW$uri\fR is found one is created.
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Glib
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2003\-2006 by the gtk2\-perl team.
.PP
This software is licensed under the \s-1LGPL\s0.  See Glib for a full notice.
