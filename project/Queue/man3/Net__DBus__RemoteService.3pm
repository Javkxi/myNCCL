.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::DBus::RemoteService 3pm"
.TH Net::DBus::RemoteService 3pm "2006-11-05" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Net::DBus::RemoteService \- Access services provided on the bus
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  my $bus = Net::DBus\->find;
\&  my $service = $bus\->get_service("org.freedesktop.DBus");
.Ve
.PP
.Vb 4
\&  my $object = $service\->get_object("/org/freedesktop/DBus");
\&  foreach (@{$object\->ListNames}) {
\&    print "$_\en";
\&  }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object provides a handle to a remote service on the
bus. From this handle it is possible to access objects
associated with the service. If a service is not running,
an attempt will be made to activate it the first time a
method is called against one of its objects.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "my $service\fR = Net::DBus::RemoteService\->new($bus, \f(CW$owner\fR, \f(CW$service_name);" 4
.el .IP "my \f(CW$service\fR = Net::DBus::RemoteService\->new($bus, \f(CW$owner\fR, \f(CW$service_name\fR);" 4
.IX Item "my $service = Net::DBus::RemoteService->new($bus, $owner, $service_name);"
Creates a new handle for a remote service. The \f(CW$bus\fR parameter is an
instance of Net::DBus, \f(CW$owner\fR is the name of the client providing the
service, while \f(CW$service_name\fR is the well known name of the  service on 
the bus. Service names consist of two or more tokens, separated
by periods, while the tokens comprise the letters a\-z, A\-Z, 0\-9 and _,
for example \f(CW\*(C`org.freedesktop.DBus\*(C'\fR. There is generally no need to call
this constructor, instead the \f(CW\*(C`get_service\*(C'\fR method on Net::DBus should
be used. This caches handles to remote services, eliminating repeated 
retrieval of introspection data.
.ie n .IP "my $bus\fR = \f(CW$service\->get_bus;" 4
.el .IP "my \f(CW$bus\fR = \f(CW$service\fR\->get_bus;" 4
.IX Item "my $bus = $service->get_bus;"
Retrieves a handle for the bus to which this service is attached.
The returned object will be an instance of Net::DBus.
.ie n .IP "my $service_name\fR = \f(CW$service\->get_service_name" 4
.el .IP "my \f(CW$service_name\fR = \f(CW$service\fR\->get_service_name" 4
.IX Item "my $service_name = $service->get_service_name"
Retrieves the name of the remote service as known to the bus.
.ie n .IP "my $owner_name\fR = \f(CW$service\->get_owner_name;" 4
.el .IP "my \f(CW$owner_name\fR = \f(CW$service\fR\->get_owner_name;" 4
.IX Item "my $owner_name = $service->get_owner_name;"
Retrieves the name of the client owning the service at the
time it was connected to. 
.ie n .IP "my $object\fR = \f(CW$service\fR\->get_object($object_path[, \f(CW$interface]);" 4
.el .IP "my \f(CW$object\fR = \f(CW$service\fR\->get_object($object_path[, \f(CW$interface\fR]);" 4
.IX Item "my $object = $service->get_object($object_path[, $interface]);"
Retrieves a handle to the remote object provided by the service  with
the name of \f(CW$object_path\fR. If the optional \f(CW$interface\fR parameter is
provided, the object will immediately be cast to the designated 
interface. \s-1NB\s0, it is only neccessary to cast an object to a specific
interface if there are multiple interfaces on the object providing
methods with the same name, or the remote object does support 
introspection. The returned object will be an instance of Net::DBus::RemoteObject.
.SH "AUTHOR"
.IX Header "AUTHOR"
Daniel Berrange <dan@berrange.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copright (C) 2004\-2005, Daniel Berrange. 
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::DBus::RemoteObject, Net::DBus::Service, Net::DBus
